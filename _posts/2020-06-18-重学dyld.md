---
Title: é‡å­¦ - dyld
date: 2020-06-18 13:00
tags:
- åŸºç¡€çŸ¥è¯†
---

### 0.01 å†™åœ¨å‰é¢

æœ¬æ–‡ä»¥ `arm64` æ¶æ„åˆ†æï¼Œå¦‚å†…å®¹æœ‰ä¸æ­£ç¡®çš„ï¼Œå¯ä»¥è”ç³»ä¿®æ”¹ã€‚ğŸ˜ã€‚
æ–‡é‡‡ä¸è¡Œï¼Œå°†å°±çœ‹ã€‚æè¿°å¯èƒ½ä¸å¤Ÿç›´æ¥ï¼Œå°†å°±çœ‹ã€‚å¯èƒ½çœç•¥äº†ï¼Œå°†å°±çœ‹ã€‚

### 0x02 launchd 

åœ¨OS X å’Œ iOS ä¸­ï¼Œç”¨æˆ·ç¯å¢ƒå§‹äº `launchd`ï¼Œå…¶å¯¹åº”äºå…¶ä»– `UN*X` ç³»ç»Ÿä¸­çš„ `init`ã€‚ä½œä¸ºç³»ç»Ÿä¸­çš„ç¬¬ä¸€ä¸ªç”¨æˆ·æ€è¿›ç¨‹ï¼Œ`launchd` æ˜¯ç”±å†…æ ¸ç›´æ¥å¯åŠ¨çš„ï¼Œè´Ÿè´£ç›´æ¥æˆ–é—´æ¥åœ°å¯åŠ¨ç³»ç»Ÿä¸­çš„å…¶ä»–è¿›ç¨‹ã€‚å…¶æ ¸å¿ƒèŒè´£æ˜¯æ ¹æ®é¢„å®šçš„å®‰æ’æˆ–å®é™…çš„éœ€è¦åŠ è½½å…¶ä»–åº”ç”¨ç¨‹åºæˆ–ä½œä¸šï¼ŒåŒæ—¶ä¹Ÿå°†è´Ÿè´£ä¸¤ç§åå°ä½œä¸šï¼š`å®ˆæŠ¤ç¨‹åº`å’Œ`ä»£ç†ç¨‹åº`ã€‚

- å®ˆæŠ¤ç¨‹åºï¼šåå°æœåŠ¡ï¼Œé€šå¸¸å’Œç”¨æˆ·æ²¡æœ‰äº¤äº’ã€‚æ˜¯ç”±ç³»ç»Ÿè‡ªåŠ¨å¯åŠ¨ï¼Œä¸è€ƒè™‘æ˜¯å¦æœ‰ç”¨æˆ·ç™»å½•è¿›ç³»ç»Ÿã€‚æ¯”å¦‚ Push é€šçŸ¥ï¼Œå¤–æ¥è®¾å¤‡å’ŒXPCç­‰ã€‚
- ä»£ç†ç¨‹åºï¼šç‰¹æ®Šçš„å®ˆæŠ¤ç¨‹åºï¼Œåªæœ‰åœ¨ç”¨æˆ·ç™»å½•çš„æ—¶å€™æ‰å¯åŠ¨ã€‚å…¶å¯ä»¥å’Œç”¨æˆ·äº¤äº’ã€‚æ¯”å¦‚ `Mac` çš„ `Finder` æˆ– `iOS` çš„ `SpringBoard` å°±æ˜¯å…¶ä¸­ä¹‹ä¸€ï¼Œå³å¹¿ä¹‰ä¸Šæˆ‘ä»¬ç†è§£çš„æ¡Œé¢ã€‚

`launchd` æ˜¯å¦‚ä½•è¢«åˆ›å»ºçš„ï¼Œéœ€è¦å»çœ‹ä¸‹ `XNU` çš„å¯åŠ¨è¿‡ç¨‹ï¼Œå…¶é«˜å±‚æ¬¡å¯åŠ¨æµç¨‹å›¾å¦‚ä¸‹ï¼š
![image-20200602225754530](http://blog.objccf.com/blog/2020-06-02-145800.png)

- `start(iOS)`ï¼šè¿™ä¸ªå‡½æ•°ä¸»è¦å¤„ç†çš„æ˜¯å¤„ç†å™¨çš„åº•å±‚è®¾ç½®ï¼šé€šè¿‡è®¾ç½® `ARM` æ§åˆ¶å¯„å­˜å™¨ï¼Œå®‰è£…ç›¸å…³çš„å†…æ ¸é™·é˜±å¤„ç†ç¨‹åºï¼Œè¿›è¡Œå…¶ä»–ä¸€äº›è®¾ç½®ï¼Œç„¶åè¿›å…¥ `arm_init` ã€‚
- `arm_init(iOS)`ï¼šåˆå§‹åŒ–å¹³å°ï¼Œä¸ºå¯åŠ¨å†…æ ¸åšå‡†å¤‡ã€‚
- `kernel_bootstrap`ï¼šè®¾ç½®å’Œåˆå§‹åŒ– `Mach` å†…æ ¸çš„å„ä¸ªæ ¸å¿ƒå­ç³»ç»Ÿã€‚ä¾‹å¦‚ï¼š`IPC`(è¿›ç¨‹é—´é€šä¿¡æ˜¯ `Mach` æ„å»ºçš„æ ¹åŸº)ã€æ—¶é’Ÿã€ä»»åŠ¡ã€çº¿ç¨‹ã€‚
- `machine_strapup`ï¼šè§£æå‘½ä»¤å‚æ•°ï¼Œä¸»è¦ç”¨æˆ·è°ƒè¯•ã€‚
- `kernel_bootstrp_thread`ï¼šä¸»çº¿ç¨‹å¼€å§‹ä»¥æ­¤çº¿ç¨‹çš„èº«ä»½è¿è¡Œï¼Œä¹‹åé¦–å…ˆåˆ›å»º `idle` çº¿ç¨‹(ç©ºé—²çº¿ç¨‹)ï¼Œåˆå§‹åŒ–``IOK it`(å³XNUçš„è®¾å¤‡é©±åŠ¨ç¨‹åºæ¡†æ¶)ã€å¯åŠ¨ä¸­æ–­ã€åˆå§‹åŒ–å…±äº«åŒºåŸŸæ¨¡å—ã€åˆå§‹åŒ– `commpage`(ä¸€ä¸ªä»å†…æ ¸ç›´æ¥æ˜ å°„åˆ°æ‰€æœ‰è¿›ç¨‹çš„é¡µé¢ï¼ŒåŒ…å«å„ç§å¯¼å‡ºæ•°æ®å’Œä¸€äº›å‡½æ•°)ã€å¦‚æœå¯ç”¨äº† `Mandatory Access Control` (å¼ºåˆ¶è®¿é—®æ§åˆ¶)ï¼Œåˆ™å¯åŠ¨ `MAC` åˆå§‹åŒ–ï¼Œè¿™å¯¹ç»´æŠ¤ç³»ç»Ÿçš„å®‰å…¨è‡³å…³é‡è¦ã€‚
- `bsd_init`ï¼šåˆå§‹åŒ–å„ä¸ªå­ç³»ç»Ÿã€‚çº¿ç¨‹ã€è¿›ç¨‹ã€æ–‡ä»¶ç³»ç»Ÿã€ç®¡é“ã€å…±äº«å†…å­˜çš„æ•£åˆ—è¡¨ç­‰ã€‚åœ¨æ­¤å‡½æ•°å¿«è¦ç»“æŸæ—¶ï¼Œä¼šè°ƒç”¨ `bsd_utaskbootstrap()`ï¼Œä¸»è¦æ˜¯é—´æ¥å¯åŠ¨ `PID1`ã€‚``bsd_utaskbootstrap()`` é¦–å…ˆåˆ›å»ºä¸€ä¸ªæ–°çš„ `Mach` ä»»åŠ¡ï¼Œä¸ºäº†çœŸæ­£çš„åˆ›å»ºä»»åŠ¡ï¼Œ``bsd_utaskbootstrap()`` å¯¹åˆ›å»ºçš„çº¿ç¨‹è°ƒç”¨ `act_set_astbsd()`ï¼Œ`act_set_astbsd()` æœ€ç»ˆä¼šè°ƒç”¨ `bsdinit_task()`ï¼Œ `bsdinit_task()` å‡½æ•°ä¸­æœ€åä¼šè°ƒç”¨ `load_init_program()`ï¼Œ`load_init_program()` è´Ÿè´£å°† `PID` ä¸º `1` çš„è¿›ç¨‹è½¬å˜ä¸ºä¼—æ‰€å‘¨çŸ¥çš„ `launchd`ã€‚

æºç çš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œ`launchd` æ˜¯æ€ä¹ˆè¢«å¯åŠ¨èµ·æ¥çš„:

```
void bsd_init(void) {
	...
    bsd_utaskbootstrap();
    ...
}
void bsd_utaskbootstrap()
{
	thread_t th_act;
	struct uthread *ut;
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„ Mach ä»»åŠ¡, æ–°çš„çº¿ç¨‹ã€‚
	th_act = cloneproc(kernproc, 0);
	initproc = pfind(1);				
	/* Set the launch time for init */
	microtime(&initproc->p_stats->p_start);
    
	ut = (struct uthread *)get_bsdthread_info(th_act);
	ut->uu_sigmask = 0;
    /// ä¸ºäº†çœŸæ­£åœ°åˆ›å»ºå‡ºæ–°çš„ä»»åŠ¡ï¼Œè°ƒç”¨å½“å‰æ–¹æ³•ç”Ÿæˆä¸€ä¸ªç³»ç»Ÿé™·é˜±(AST)ï¼Œå½“å¤„ç† AST æ—¶ï¼ŒMachçš„ASTå¤„ç†ç¨‹åºä¼šç‰¹åˆ«å¤„ç†è¿™ä¸ªç‰¹æ®Šæƒ…å†µï¼Œè°ƒç”¨ bsd_ast()ï¼Œbsd_ast()è°ƒç”¨ bsdinit_task()
	act_set_astbsd(th_act);
	(void) thread_resume(th_act);
}
void
bsdinit_task(void)
{
	struct proc *p = current_proc();
	struct uthread *ut;
	kern_return_t	kr;
	thread_t th_act;
	shared_region_mapping_t system_region;
    /// å°†åˆå§‹è¿›ç¨‹çš„åå­—è®¾ç½®ä¸º init
	 zprocess_name("init", p);
    /// åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„å†…æ ¸çº¿ç¨‹ ux_handlerï¼Œè¿™ä¸ªçº¿ç¨‹è´Ÿè´£å¤„ç† UNIX å¼‚å¸¸ï¼Œå°±æ˜¯åœ¨ä¸€ä¸ªå…¨å±€çš„ un_exception_port ç«¯å£ä¸Šæ¥æ”¶æ¶ˆæ¯
	ux_handler_init();

	th_act = current_thread();
    /// æ³¨å†Œ init çº¿ç¨‹çš„å¼‚å¸¸ç«¯å£ï¼Œå°†è¿™ä¸ªå…¨å±€ç«¯å£æ³¨å†Œä¸ºè‡ªå·±çš„ç«¯å£ï¼Œè¿™æ ·å¯ä»¥ä¿è¯ initï¼Œä»¥åŠæ‰€æœ‰UNIX è¿›ç¨‹çš„æ‰€æœ‰ UNIX å¼‚å¸¸éƒ½ä¼šè¢«å¤„ç†
	(void) host_set_exception_ports(host_priv_self(),
					EXC_MASK_ALL & ~(EXC_MASK_SYSCALL |
							 EXC_MASK_MACH_SYSCALL |
							 EXC_MASK_RPC_ALERT),
					ux_exception_port,
					EXCEPTION_DEFAULT, 0);

	(void) task_set_exception_ports(get_threadtask(th_act),
					EXC_MASK_ALL & ~(EXC_MASK_SYSCALL |
							 EXC_MASK_MACH_SYSCALL |
							 EXC_MASK_RPC_ALERT),
					ux_exception_port,
					EXCEPTION_DEFAULT, 0);




	ut = (uthread_t)get_bsdthread_info(th_act);
	ut->uu_ar0 = (void *)get_user_regs(th_act);

	bsd_hardclockinit = 1;	/* Start bsd hardclock */
	bsd_init_task = get_threadtask(th_act);
	init_task_failure_data[0] = 0;
	system_region = lookup_default_shared_region(ENV_DEFAULT_ROOT, cpu_type());
        if (system_region == NULL) {
		shared_file_boot_time_init(ENV_DEFAULT_ROOT, cpu_type());
	} else {
		vm_set_shared_region(get_threadtask(th_act), system_region);
	}
    /// åŠ è½½ launchd
	load_init_program(p);
	/* turn on app-profiling i.e. pre-heating */
	app_profile = 1;
	lock_trace = 1;
}
static char		init_program_name[128] = "/sbin/launchd";
/*
 åŠ è½½ init ç¨‹åºï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹ init ç¨‹åºä¸º launchd
 å‚æ•° p è°ƒç”¨ execv() åˆ›å»º init ç¨‹åºçš„è¿›ç¨‹
 è¯´æ˜ï¼šä¼ å…¥çš„è¿›ç¨‹æ˜¯ç³»ç»Ÿä¸­åˆ›å»ºçš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œè€Œä¸”é€šè¿‡ bsd_ast() ç¬¬ä¸€æ¬¡è§¦å‘è¿›å…¥åˆ°è¿™é‡Œã€‚è¿™ä¹ˆåšæ˜¯ä¸ºäº†å®æˆ bsd_init() è¿è¡Œå®Œæˆ
 */
void
load_init_program(struct proc *p)
{
	vm_offset_t	init_addr;
	char		*argv[3];
	int			error;
	register_t 	retval[2];

	error = 0;
    
    /// ç›´æ¥ä»å¼•å¯¼ç¨‹åºä»¥å­—ç¬¦ä¸²å½¢å¼å¤åˆ¶init_args
	do {
		if (boothowto & RB_INITNAME) {
			printf("init program? ");
#if FIXME  /* [ */
			gets(init_program_name, init_program_name);
#endif  /* FIXME ] */
		}

        /// å°†ç¨‹åºåå¤åˆ¶åˆ°ç”¨æˆ·åœ°å€ç©ºé—´
        init_addr = VM_MIN_ADDRESS;
        (void) vm_allocate(current_map(), &init_addr,
                   PAGE_SIZE, VM_FLAGS_ANYWHERE);
        if (init_addr == 0)
            init_addr++;

        (void) copyout((caddr_t) init_program_name,
                CAST_USER_ADDR_T(init_addr),
                (unsigned) sizeof(init_program_name)+1);

        argv[0] = (char *) init_addr;
        init_addr += sizeof(init_program_name);
        init_addr = (vm_offset_t)ROUND_PTR(char, init_addr);

        /// ç±»ä¼¼åœ°ï¼Œå°†ç¬¬ä¸€ä¸ª(ä¹Ÿæ˜¯å”¯ä¸€çš„)å‚æ•°ä¹Ÿå¤åˆ¶å‡ºæ¥
        /// å‡è®¾å¤åˆ¶å‡ºæ¥çš„å†…å®¹éƒ½èƒ½æ”¾è¿›ä¹‹å‰åˆ†é…çš„ä¸€ä¸ªé¡µé¢ä¸­
        (void) copyout((caddr_t) init_args,
                CAST_USER_ADDR_T(init_addr),
                (unsigned) sizeof(init_args));

        argv[1] = (char *) init_addr;
        init_addr += sizeof(init_args);
        init_addr = (vm_offset_t)ROUND_PTR(char, init_addr);
        /// Null ç»“å°¾çš„å‚æ•°åˆ—è¡¨
        argv[2] = (char *) 0;
        /// å°†å‚æ•°åˆ—è¡¨å¤åˆ¶å‡ºæ¥
        (void) copyout((caddr_t) argv,
                CAST_USER_ADDR_T(init_addr),
                (unsigned) sizeof(argv));
        /// è®¾ç½®å‚æ•°å¿«ï¼Œè°ƒç”¨ execve æ—¶ä½¿ç”¨
        init_exec_args.fname = CAST_USER_ADDR_T(argv[0]);
        init_exec_args.argp = CAST_USER_ADDR_T((char **)init_addr);
        init_exec_args.envp = CAST_USER_ADDR_T(0);
        /// mach_init ä»»åŠ¡è®¾ç½® uidã€gid ä¸º 0 çš„ä»¤ç‰Œ
        set_security_token(p);
		/// å¯åŠ¨
		error = execve(p,&init_exec_args,retval);
	} while (error);
}
```

### 0x03 Mach-O æ ¼å¼

å‚è€ƒ[Mach-O](http://www.ioscarp.com/2018/09/03/Mach_O.html)

### 0x03 åœ°å€ç©ºé—´å¸ƒå±€éšæœºåŒ–(ASLR)

`ASLR` é€šè¿‡éšæœºæ”¾ç½®è¿›ç¨‹å…³é”®æ•°æ®åŒºåŸŸçš„åœ°å€ç©ºé—´æ¥é˜²æ­¢æ”»å‡»è€…èƒ½å¯é åœ°è·³è½¬åˆ°å†…å­˜çš„ç‰¹å®šä½ç½®æ¥åˆ©ç”¨å‡½æ•°ã€‚ç°ä»£æ“ä½œç³»ç»Ÿä¸€èˆ¬éƒ½åŠ è®¾è¿™ä¸€æœºåˆ¶ï¼Œä»¥é˜²èŒƒæ¶æ„ç¨‹åºå¯¹å·²çŸ¥åœ°å€è¿›è¡Œ `Return-to-libc` æ”»å‡»ã€‚
`ASLR` åˆ©ç”¨`éšæœºæ–¹å¼é…ç½®æ•°æ®åœ°å€ç©ºé—´`ï¼Œä½¿æŸäº›æ•æ„Ÿæ•°æ®ï¼ˆä¾‹å¦‚æ“ä½œç³»ç»Ÿå†…æ ¸ï¼‰é…ç½®åˆ°ä¸€ä¸ªæ¶æ„ç¨‹åºæ— æ³•äº‹å…ˆè·çŸ¥çš„åœ°å€ï¼Œä»¤æ”»å‡»è€…éš¾ä»¥è¿›è¡Œæ”»å‡»ã€‚
è¿›ç¨‹æ¯ä¸€æ¬¡å¯åŠ¨æ—¶ï¼Œåœ°å€ç©ºé—´éƒ½å°†è¢«éšæœºåŒ–ï¼Œå³åç§»ã€‚å®ç°æ–¹æ³•æ˜¯é€šè¿‡å†…æ ¸å°† `Mach-O` çš„ `Segment` å¹³ç§»æŸä¸ªéšæœºç³»æ•°ã€‚åé¢çš„ä»£ç é˜…è¯»ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šé‡åˆ°è¿™ä¸ªæŠ€æœ¯ã€‚

### 0x05 dyld è¢«åŠ è½½è¿‡ç¨‹

#### 1. execve()

ç´§æ¥ç€ `0x01` çš„ `execve()` åˆ†æï¼Œä¸‹é¢æ˜¯ç®€åŒ–åçš„æºç åˆ†æï¼š

```
/*
 p å½“å‰è¿›ç¨‹
 uap æ˜¯åœ¨åŠ è½½load_init_programå‡½æ•°ä¼ è¿‡æ¥çš„ 3 ä¸ªå‚æ•°ã€‚
    uap->fname æ–‡ä»¶å
    uap->argp å‚æ•°åˆ—è¡¨
    uap->envp ç¯å¢ƒå‚æ•°
 retvalï¼šç»™ä¸Šå±‚çš„è¿”å›å€¼ï¼Œå‡½æ•°è‡ªèº«è¿”å› 0 åˆ™æˆåŠŸ
*/
int execve {
	struct __mac_execve_args muap;
	int err;

	memoryshot(VM_EXECVE, DBG_FUNC_NONE);

	muap.fname = uap->fname;
	muap.argp = uap->argp;
	muap.envp = uap->envp;
	muap.mac_p = USER_ADDR_NULL;
	err = __mac_execve(p, &muap, retval);
	return err;
}
```

##### 1.1 mac_execve

`mac_execve` æºç çš„ç®€åŒ–åˆ†æï¼š

```
int __mac_execve(proc_t p, struct __mac_execve_args *uap, int32_t *retval)
{
    ...
	
    /// ä¸ºæœ¬åœ°äººåˆ†é…ä¸€ä¸ªå¾ˆå¤§çš„å—ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å †æ ˆï¼Œå› ä¸ºè¿™äº›ç»“æ„å¾ˆå¤§ã€‚
	MALLOC(bufp, char *, (sizeof(*imgp) + sizeof(*vap) + sizeof(*origvap)), M_TEMP, M_WAITOK | M_ZERO);
	imgp = (struct image_params *) bufp;
    ..

	/// åˆå§‹åŒ–
	imgp->ip_user_fname = uap->fname;
	imgp->ip_user_argv = uap->argp;
	imgp->ip_user_envv = uap->envp;
	imgp->ip_vattr = vap;
	imgp->ip_origvattr = origvap;
	imgp->ip_vfs_context = &context;
	imgp->ip_flags = (is_64 ? IMGPF_WAS_64BIT_ADDR : IMGPF_NONE) | ((p->p_flag & P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);
	imgp->ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);
	imgp->ip_mac_return = 0;
	imgp->ip_cs_error = OS_REASON_NULL;
	imgp->ip_simulator_binary = IMGPF_SB_DEFAULT;

    ...
    // ç¨‹åºå¯åŠ¨éœ€è¦forkä¸€æ¡æ–°çš„è¿›ç¨‹ï¼Œä¼šèµ°è¿™ä¸ªelseåˆ†æ”¯
	uthread = get_bsdthread_info(current_thread());
	if (uthread->uu_flag & UT_VFORK) {
		imgp->ip_flags |= IMGPF_VFORK_EXEC;
		in_vfexec = TRUE;
	} else {
		imgp->ip_flags |= IMGPF_EXEC;

		imgp->ip_new_thread = fork_create_child(old_task,
		    NULL,
		    p,
		    FALSE,
		    p->p_flag & P_LP64,
		    task_get_64bit_data(old_task),
		    TRUE);
		/* task and thread ref returned by fork_create_child */
		if (imgp->ip_new_thread == NULL) {
			error = ENOMEM;
			goto exit_with_error;
		}

		new_task = get_threadtask(imgp->ip_new_thread);
		context.vc_thread = imgp->ip_new_thread;
	}
    
     // è§£æç¨‹åº
	error = exec_activate_image(imgp);

    // è®¾ç½®è¿›ç¨‹çš„ä¸»çº¿ç¨‹
	if (!error) {
        ...

		thread_t main_thread = imgp->ip_new_thread;

		task_set_main_thread_qos(new_task, main_thread);
        ...
	}
    ...
	return error;
}
```

##### 1.2 exec_activate_image

`exec_activate_image` æºç çš„ç®€åŒ–åˆ†æï¼š

```
static int
exec_activate_image(struct image_params *imgp)
{
    ...
    /// åˆ†é…å†…å­˜ï¼Œæƒé™æ£€æŸ¥ï¼Œ
	error = execargs_alloc(imgp);
	if (error) {
		goto bad_notrans;
	}
    /// å°†ç¬¬ä¸€ä¸ªå‚æ•°å­˜å‚¨åˆ°å †æ ˆä¸­
	error = exec_save_path(imgp, imgp->ip_user_fname, imgp->ip_seg, &excpath);
	if (error) {
		goto bad_notrans;
	}
    ...
    
    /// é€šè¿‡ namei() æ–¹æ³•æ‰¾åˆ°è¯¥äºŒè¿›åˆ¶æ–‡ä»¶
	error = namei(ndp);
	if (error) {
		goto bad_notrans;
	}
    ...
    /// ä½¿ç”¨ vn æ¥å£(è·Ÿæ–‡ä»¶ç³»ç»Ÿæ— å…³çš„æŠ½è±¡æ¥å£)è¯»å–æ–‡ä»¶å¤´ï¼Œæœ€å¤šè¯»ä¸€é¡µã€‚
	error = vn_rdwr(UIO_READ, imgp->ip_vp, imgp->ip_vdata, PAGE_SIZE, 0,
	    UIO_SYSSPACE, IO_NODELOCKED,
	    vfs_context_ucred(imgp->ip_vfs_context),
	    &resid, vfs_context_proc(imgp->ip_vfs_context));
    ...
    
    /// è¯»åˆ°æ–‡ä»¶å¤´ä¿¡æ¯ä¹‹åå†å¾ªç¯èµ°ä¸€éï¼Œåˆ¤æ–­æ˜¯å¦å¦‚ä¸‹ä¸‰ç§:
	for (i = 0; error == -1 && execsw[i].ex_imgact != NULL; i++) {
		error = (*execsw[i].ex_imgact)(imgp);
        /// æ‰¾åˆ°äº†å°±ä½¿ç”¨å¯¹åº” ex_imgact è½¬æˆå‡½æ•°æŒ‡é’ˆç„¶åè°ƒç”¨å®ƒï¼Œä¼ å…¥ imgp å‚æ•°ã€‚
        /// è¿™é‡Œå¯¹machoæ–‡ä»¶è¿›è¡Œäº†è§£æ
        error = (*execsw[i].ex_imgact)(imgp);
        /// todo:è°ƒç”¨äº†ä¸€ä¸ªæŒ‡é’ˆå‡½æ•°ï¼Œexec_mach_imgact
        //æ€»å…±æœ‰ä¸‰ç§å‡½æ•°
        /*
            struct execsw {
            int (*ex_imgact)(struct image_params *);
            const char *ex_name;
            } execsw[] = {
            { exec_mach_imgact,        "Mach-O Binary" },
            { exec_fat_imgact,        "Fat Binary" },
            { exec_shell_imgact,        "Interpreter Script" },
            { NULL, NULL}
        };
        */
        switch (error) {
            /*å‡ºé”™å¤„ç†*/
            ...
        }
	}
    ...
    return(error);
}
```

##### 1.3 å°æ®µæ€»ç»“

ä¸Šè¿°å‡½æ•°ï¼Œä¸»è¦å°±æ˜¯å¯»æ‰¾å¹¶æ‹·è´å¯æ‰§è¡Œæ–‡ä»¶åˆ°å†…å­˜ä¸­ï¼Œå¹¶ä¸”æ ¹æ®å¯æ‰§è¡Œæ–‡ä»¶çš„ç±»å‹è°ƒç”¨ä¸èƒ½çš„è§£æå‡½æ•°ã€‚`iOS` å…±æ”¯æŒä¸‰ç§å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå„è‡ªå¯¹åº”çš„è§£æå‡½æ•°å¦‚ä¸‹ï¼š

- `Mach-O Binary` (æ™®é€šçš„å•æ¶æ„ `Mach-O` äºŒè¿›åˆ¶æ–‡ä»¶) ï¼š``exec_mach_imgact`
- `Fat Binary`(å¤šæ¶æ„ `Mach-O` èƒ–äºŒè¿›åˆ¶æ–‡ä»¶)ï¼š``exec_fat_imgact`
- `Interpreter Script`(è„šæœ¬)ï¼š``exec_shell_imgact`

#### 2. exec_mach_imgact

ä¸‹é¢æ˜¯æ ¸å¿ƒå‡½æ•° `exec_mach_imgact` çš„ç®€åŒ–æºç åˆ†æï¼š

```
/*
 * exec_mach_imgact
 *
 * ç”¨äºMach-O 1.0äºŒè¿›åˆ¶æ–‡ä»¶çš„å›¾åƒæ¿€æ´»å™¨ã€‚
 *
 * è¿”å›:
 *  -1: ä¸æ˜¯èƒ–äºŒè¿›åˆ¶æ–‡ä»¶
 *  -2:	äºŒè¿›åˆ¶æ–‡ä»¶
 *  >0: é”™è¯¯
 *	EBADARCH: Mach-OäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä½†æ— æ³•è¯†åˆ«
 *  ENOMEM			No memory for child process after -
 *					can only happen after vfork()
 *
 * Important:	æ­¤å›¾åƒæ¿€æ´»å™¨ä¸æ˜¯å­—èŠ‚é¡ºåºä¸­æ€§çš„ã€‚
 *
 * Note: -1ä»¥å¤–çš„è¿”å›å€¼è¡¨ç¤ºä¸åº”ä¸ºåç»­çš„å›¾åƒæ¿€æ´»å™¨æä¾›å°è¯•æ¿€æ´»å›¾åƒçš„æœºä¼šã€‚
 */
static int exec_mach_imgact(struct image_params *imgp) {
    /// è·å– mach_header
	struct mach_header *mach_header = (struct mach_header *)imgp->ip_vdata;
    ...
    
    /// é€šè¿‡æ£€æµ‹ mach_header é‡Œçš„ magicï¼ŒæŸ¥çœ‹å…¶æ˜¯å¦ç¬¦å· Mach-O å¯æ‰§è¡Œæ–‡ä»¶çš„ç‰¹å¾
    /// é€†åºMach-OäºŒè¿›åˆ¶æ–‡ä»¶å¯è¯†åˆ«ä½†ä¸å…¼å®¹ã€‚
	if ((mach_header->magic == MH_CIGAM) ||
	    (mach_header->magic == MH_CIGAM_64)) {
		error = EBADARCH;
		goto bad;
	}

	if ((mach_header->magic != MH_MAGIC) &&
	    (mach_header->magic != MH_MAGIC_64)) {
		error = -1;
		goto bad;
	}
    /// æ£€æµ‹Mach-Oçš„æ–‡ä»¶ç±»å‹ï¼Œæ–‡ä»¶ç±»å‹å¿…é¡»æ˜¯å¯æ‰§è¡Œæ–‡ä»¶
    // è¿˜æœ‰ä¸€äº›å…¶ä»–çš„å¸¸è§ç±»å‹
    // #define    MH_OBJECT    0x1        ç¼–è¯‘è¿‡ç¨‹äº§ç”Ÿçš„objæ–‡ä»¶
    // #define    MH_CORE        0x4        å´©æºƒæ—¶çš„dumpæ–‡ä»¶
	if (mach_header->filetype != MH_EXECUTE) {
		error = -1;
		goto bad;
	}
    /// è·å–Mach-Oçš„æ‰§è¡Œç¯å¢ƒï¼Œcpuçš„å¹³å°ä¸ç‰ˆæœ¬
	if (imgp->ip_origcputype != 0) {
		/* Fat header previously had an idea about this thin file */
		if (imgp->ip_origcputype != mach_header->cputype ||
		    imgp->ip_origcpusubtype != mach_header->cpusubtype) {
			error = EBADARCH;
			goto bad;
		}
	} else {
		imgp->ip_origcputype = mach_header->cputype;
		imgp->ip_origcpusubtype = mach_header->cpusubtype;
    }
    ...
    
grade:
    /// æ£€æµ‹ Mach-O çš„ cpu å¹³å°
	if (!grade_binary(imgp->ip_origcputype, imgp->ip_origcpusubtype & ~CPU_SUBTYPE_MASK, TRUE)) {
		error = EBADARCH;
		goto bad;
	}
    ...

    /// è·å–ç¯å¢ƒå˜é‡å’Œå‚æ•°ï¼Œä¸ºvforkæ‰§è¡Œmachoåšå‡†å¤‡
	error = exec_extract_strings(imgp);
	if (error) {
		goto bad;
	}
    ...
    
    /// é€šè¿‡forkï¼Œä¸ºmachoç”Ÿæˆä¸€ä¸ªæ–°çš„çº¿ç¨‹
	if (vfexec) {
		imgp->ip_new_thread = fork_create_child(task,
		    NULL,
		    p,
		    FALSE,
		    (imgp->ip_flags & IMGPF_IS_64BIT_ADDR),
		    (imgp->ip_flags & IMGPF_IS_64BIT_DATA),
		    FALSE);
		/* task and thread ref returned, will be released in __mac_execve */
		if (imgp->ip_new_thread == NULL) {
			error = ENOMEM;
			goto bad;
		}
	}
    ...
    
	/// åŠ è½½ï¼Œæ˜ å°„machoæ–‡ä»¶åˆ°å†…å­˜
	lret = load_machfile(imgp, mach_header, thread, &map, &load_result);
    ...
    
	//è®¾ç½®äº†ä¸€å †æ ‡è®°ä½
    //éœ€è¦å…³å¿ƒä¸€ä¸‹çš„æ˜¯è¿™é‡Œå’Œcode-signginæœ‰ç‚¹å…³ç³»
	if (load_result.csflags & CS_VALID) {
		imgp->ip_csflags |= load_result.csflags &
		    (CS_VALID | CS_SIGNED | CS_DEV_CODE |
		    CS_HARD | CS_KILL | CS_RESTRICT | CS_ENFORCEMENT | CS_REQUIRE_LV |
		    CS_FORCED_LV | CS_ENTITLEMENTS_VALIDATED | CS_DYLD_PLATFORM | CS_RUNTIME |
		    CS_ENTITLEMENT_FLAGS |
		    CS_EXEC_SET_HARD | CS_EXEC_SET_KILL | CS_EXEC_SET_ENFORCEMENT);
	} else {
		imgp->ip_csflags &= ~CS_VALID;
	}

	if (p->p_csflags & CS_EXEC_SET_HARD) {
		imgp->ip_csflags |= CS_HARD;
	}
	if (p->p_csflags & CS_EXEC_SET_KILL) {
		imgp->ip_csflags |= CS_KILL;
	}
	if (p->p_csflags & CS_EXEC_SET_ENFORCEMENT) {
		imgp->ip_csflags |= CS_ENFORCEMENT;
	}
	if (p->p_csflags & CS_EXEC_INHERIT_SIP) {
		if (p->p_csflags & CS_INSTALLER) {
			imgp->ip_csflags |= CS_INSTALLER;
		}
		if (p->p_csflags & CS_DATAVAULT_CONTROLLER) {
			imgp->ip_csflags |= CS_DATAVAULT_CONTROLLER;
		}
		if (p->p_csflags & CS_NVRAM_UNRESTRICTED) {
			imgp->ip_csflags |= CS_NVRAM_UNRESTRICTED;
		}
	}

	/// åœ¨æ–°çš„åœ°å€ç©ºé—´ä¸­è®¾ç½®ç³»ç»Ÿä¿ç•™åŒºã€‚
    /// æ‰€æœ‰cpu_subtypesä½¿ç”¨ç›¸åŒçš„å…±äº«åŒºåŸŸ
	int cpu_subtype;
	cpu_subtype = 0; /* all cpu_subtypes use the same shared region */
#if defined(HAS_APPLE_PAC)
	if (cpu_type() == CPU_TYPE_ARM64 &&
	    (p->p_cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {
		assertf(p->p_cputype == CPU_TYPE_ARM64,
		    "p %p cpu_type() 0x%x p->p_cputype 0x%x p->p_cpusubtype 0x%x",
		    p, cpu_type(), p->p_cputype, p->p_cpusubtype);
		/*
		 * arm64e uses pointer authentication, so request a separate
		 * shared region for this CPU subtype.
		 */
		cpu_subtype = p->p_cpusubtype & ~CPU_SUBTYPE_MASK;
	}
#endif /* HAS_APPLE_PAC */
    /// ä¾æ®å¯æ‰§è¡Œæ–‡ä»¶çš„å¹³å°ï¼Œè®¾ç½®åˆé€‚çš„æ‰§è¡Œç¯å¢ƒ
	vm_map_exec(map, task, load_result.is_64bit_addr, (void *)p->p_fd->fd_rdir, cpu_type(), cpu_subtype);

	/// å…³é—­æ‰€æœ‰è¢«æ ‡è®°ä¸ºclose-on-execçš„æ–‡ä»¶
	fdexec(p, psa != NULL ? psa->psa_flags : 0, exec);

	/// å¤„ç†setuidç›¸å…³çš„é€»è¾‘ï¼Œå’Œæƒé™ç›¸å…³
	error = exec_handle_sugid(imgp);
    ...
    
    /// å¤„ç†ä¸Šé¢ Mach-O çš„åŠ è½½ç»“æœ
	lret = activate_exec_state(task, p, thread, &load_result);
	...
	
    /// ä¸ºè¿›ç¨‹è®¾ç½®åº”ç”¨å±‚çš„æ ˆåœ°å€
	if (load_result.unixproc &&
	    create_unix_stack(get_task_map(task),
        ...
    }
    ...
            
	if (load_result.dynlinker) {
        ....
        
        /// è®¾ç½®ä¸€äº›dyldéœ€è¦ä½¿ç”¨çš„å‚æ•°
		task_set_dyld_info(task, load_result.all_image_info_addr,
		    load_result.all_image_info_size);
	}

	/// é¿å…è™šæ‹Ÿæœºç«‹å³å‡ºç°æ•…éšœå›åˆ°å†…æ ¸
	exec_prefault_data(p, imgp, &load_result);

	/// é‡ç½®ä¿¡å·çŠ¶æ€
	execsigs(p, thread);

    /// éœ€è¦å–æ¶ˆå¯ä»¥å–æ¶ˆçš„å¼‚æ­¥IOè¯·æ±‚ï¼Œå¹¶ç­‰å¾…å·²æ¿€æ´»çš„è¯·æ±‚ã€‚ å¯èƒ½ä¼šé˜»å¡ï¼
	_aio_exec( p )
    ...
}
```

è¯¥å‡½æ•°ä¸»è¦ä½œç”¨ï¼š

- å¯¹ `macho`æ–‡ä»¶åšæœ€åŸºæœ¬çš„æ£€æµ‹
- `fork`æ–°çš„çº¿ç¨‹è¿è¡Œ `macho`
- æ˜ å°„ `macho` æ–‡ä»¶åˆ°å†…å­˜ä¸­
- å¯¹ `setuid`ï¼Œ`code-sign` ç­‰æƒé™ç›¸å…³çš„äº‹æƒ…æœ‰å¤„ç†
- ä¸º `dyld` æ¥æ‰‹ `macho` æ–‡ä»¶çš„å¤„ç†åšäº†å¤§é‡çš„å‡†å¤‡å·¥ä½œ
- `dyld` å¤„ç†å®Œä¹‹åï¼Œå¯¹èµ„æºçš„é‡Šæ”¾

##### 2.1 load_machfile

`load_machfile` æºç çš„ç®€åŒ–åˆ†æ

```
load_return_t load_machfile {
    ...
    /// å¦‚æœæœ‰new_mapå°±ç”¨å‚æ•°ä¼ è¿›æ¥çš„new_map
    /// å¦åˆ™å°±é€šè¿‡pmap_create,vm_map_createå‡½æ•°åˆ›å»ºæ–°çš„å†…å­˜ç©ºé—´
	task_t ledger_task;
	if (imgp->ip_new_thread) {
		ledger_task = get_threadtask(imgp->ip_new_thread);
	} else {
		ledger_task = task;
	}
	pmap = pmap_create_options(get_task_ledger(ledger_task),
	    (vm_map_size_t) 0,
	    pmap_flags);
	if (pmap == NULL) {
		return LOAD_RESOURCE;
	}
	map = vm_map_create(pmap,
	    0,
	    vm_compute_max_offset(result->is_64bit_addr),
	    TRUE);

#if defined(__arm64__)
	if (result->is_64bit_addr) {
		/// å¼ºåˆ¶è™šæ‹Ÿæ˜ å°„æ¡ç›®çš„16KBå¯¹é½
		vm_map_set_page_shift(map, SIXTEENK_PAGE_SHIFT);
	} else {
		vm_map_set_page_shift(map, page_shift_user32);
	}
#elif (__ARM_ARCH_7K__ >= 2) && defined(PLATFORM_WatchOS)
	/// ä½¿ç”¨æ–°çš„ABIå¯¹ç›‘è§†ç›®æ ‡å¼ºåˆ¶æ‰§è¡Œ16KBå¯¹é½
	vm_map_set_page_shift(map, SIXTEENK_PAGE_SHIFT);
#endif /* __arm64__ */

#ifndef CONFIG_ENFORCE_SIGNED_CODE
    /// å¯ä»¥å…³é—­å¯æ‰§è¡Œé¡µé¢çš„é”™è¯¯ï¼Œä»è€Œå¯ä»¥ç»•è¿‡ä»£ç ç­¾åå®æ–½ã€‚
    /// æ¯ä¸ªè¿›ç¨‹æ ‡å¿—ï¼ˆCS_ENFORCEMENTï¼‰å°šæœªè®¾ç½®ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…¨å±€æ ‡å¿—ã€‚
	if (!cs_process_global_enforcement() && (header->flags & MH_ALLOW_STACK_EXECUTION)) {
		vm_map_disable_NX(map);
		// TODO: Message Trace or log that this is happening
	}
#endif

	/// å°†å†…å­˜è®¾ç½®ä¸ºä¸å¯æ‰§è¡Œï¼Œç”¨æ¥é˜²æ­¢æº¢å‡ºæ¼æ´çš„åˆ©ç”¨
	if ((header->flags & MH_NO_HEAP_EXECUTION) && !(imgp->ip_flags & IMGPF_ALLOW_DATA_EXEC)) {
		vm_map_disallow_data_exec(map);
	}

    /// //åœ°å€éšæœºï¼Œè®¡ç®—ASLRçš„åç§»é‡
	if (!(imgp->ip_flags & IMGPF_DISABLE_ASLR)) {
		vm_map_get_max_aslr_slide_section(map, &aslr_section_offset, &aslr_section_size);
		aslr_section_offset = (random() % aslr_section_offset) * aslr_section_size;

		aslr_page_offset = random();
		aslr_page_offset %= vm_map_get_max_aslr_slide_pages(map);
		aslr_page_offset <<= vm_map_page_shift(map);

		dyld_aslr_page_offset = random();
		dyld_aslr_page_offset %= vm_map_get_max_loader_aslr_slide_pages(map);
		dyld_aslr_page_offset <<= vm_map_page_shift(map);

		aslr_page_offset += aslr_section_offset;
	}
    ...
    /// è§£æmachoçš„æ–‡ä»¶æ ¼å¼
    
	lret = parse_machfile(vp, map, thread, header, file_offset, macho_size,
	    0, aslr_page_offset, dyld_aslr_page_offset, result,
	    NULL, imgp);

    ...
    /// ç”¨æ–°ç”³è¯·çš„å†…å­˜æ›¿æ¢åŸæ¥çš„å†…å­˜
	if (in_exec) {
		proc_t p = vfs_context_proc(imgp->ip_vfs_context);
    
		kret = task_start_halt(task);
		if (kret != KERN_SUCCESS) {
			vm_map_deallocate(map); /* will lose pmap reference too */
			return LOAD_FAILURE;
		}
		proc_transcommit(p, 0);
		workq_mark_exiting(p);
		task_complete_halt(task);
		workq_exit(p);

		/*
		 * Roll up accounting info to new task. The roll up is done after
		 * task_complete_halt to make sure the thread accounting info is
		 * rolled up to current_task.
		 */
		task_rollup_accounting_info(get_threadtask(thread), task);
	}
	*mapp = map;
    ....
}
```

è¯¥å‡½æ•°çš„ä½œç”¨ï¼š

- å¯¹æ–°çš„ `task`  è¿›è¡Œå†…å­˜åˆ†é…ï¼Œå†…å­˜å¯¹é½ã€‚
- åŠ å¼ºå®‰å…¨æ–¹é¢çš„è®¾ç½®ä¸»è¦æ˜¯ `DEP` å’Œ `ASRL`ã€‚
- è°ƒç”¨ `parse_machfile` å‡½æ•°è§£æ `Mach-O` æ–‡ä»¶ã€‚
- è§£ææˆåŠŸä¹‹åï¼Œç”¨æ–°ç”³è¯·çš„å†…å­˜æ›¿æ¢æ—§çš„å†…å­˜ã€‚

###### 2.1.1 parse_machfile

`parse_machfile` æºç çš„ç®€åŒ–åˆ†æï¼š

```
static load_return_t parse_machfile{
    ... éšè—äº†åˆå§‹åŒ–ä¸æ£€æµ‹
    
    /// é€šè¿‡æ£€æµ‹ mach_header é‡Œçš„ magicï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯ 64 ä½è®¾å¤‡
	if (header->magic == MH_MAGIC_64 ||
	    header->magic == MH_CIGAM_64) {
		mach_header_sz = sizeof(struct mach_header_64);
	}

	/// é˜²æ­¢æ— é™é€’å½’
	if (depth > 1) {
		return LOAD_FAILURE;
	}
    /// æ­¤å‡½æ•°ä¼šè¢«éå†ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡è§£æä¸»ç¨‹åºçš„Mach-Oï¼Œç¬¬äºŒæ¬¡è§£ædyld
	depth++;
    
	/// é€šè¿‡mach_headerï¼Œæ ¡éªŒæ–‡ä»¶çš„CPUæ¶æ„å’Œå½“å‰è¿è¡Œç¯å¢ƒçš„CPUæ¶æ„æ˜¯å¦ä¸€è‡´
	if (((cpu_type_t)(header->cputype & ~CPU_ARCH_MASK) != (cpu_type() & ~CPU_ARCH_MASK)) ||
	    !grade_binary(header->cputype,
	    header->cpusubtype & ~CPU_SUBTYPE_MASK, TRUE)) {
		return LOAD_BADARCH;
	}

	abi64 = ((header->cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64);
    /// æ ¹æ®æ–‡ä»¶ç±»å‹ï¼ŒåŒºåˆ«å¤„ç†
	switch (header->filetype) {
        /// å¦‚æœæ˜¯åº”ç”¨ç¨‹åºï¼Œå³app
        case MH_EXECUTE:
            if (depth != 1) {
                return LOAD_FAILURE;
            }
#if CONFIG_EMBEDDED
            /// å¦‚æœéœ€è¦ä½œä¸ºåŠ¨æ€é“¾æ¥å™¨çš„è¾“å…¥æ–‡ä»¶ï¼Œè‚¯å®šä¼šè¿›å…¥è¿™é‡Œï¼Œå› ä¸ºdyldè¿˜éœ€è¦è§£æä¸€æ¬¡ä¸»ç¨‹åº
            if (header->flags & MH_DYLDLINK) {
			/// æ£€æŸ¥åŠ¨æ€å¯æ‰§è¡Œæ–‡ä»¶çš„å±æ€§
			if (!(header->flags & MH_PIE) && pie_required(header->cputype, header->cpusubtype & ~CPU_SUBTYPE_MASK)) {
				return LOAD_FAILURE;
			}
			result->needs_dynlinker = TRUE;
            } else {
                /// æ£€æŸ¥é™æ€å¯æ‰§è¡Œæ–‡ä»¶çš„å±æ€§ï¼ˆå¼€å‘é™¤å¤–ï¼‰
#if !(DEVELOPMENT || DEBUG)
                return LOAD_FAILURE;
#endif
            }
#endif /* CONFIG_EMBEDDED */

            break;
        /// å¦‚æœæ˜¯åŠ¨æ€é“¾æ¥å™¨
        case MH_DYLINKER:
            if (depth != 2) {
                return LOAD_FAILURE;
            }
            is_dyld = TRUE;
            break;

        default:
            return LOAD_FAILURE;
    }
    ...
    
    /// å°†åŠ è½½å‘½ä»¤æ˜ å°„åˆ°å†…æ ¸å†…å­˜ã€‚
	addr = kalloc(alloc_size);
	if (addr == NULL) {
		return LOAD_NOSPACE;
	}
    ...

	/// å¯¹äºPIEå’Œdyldï¼Œå°±å°†éšæœºåœ°å€çš„åç§»å€¼èµ‹ç»™slide
	if ((header->flags & MH_PIE) || is_dyld) {
		slide = aslr_offset;
	}

	/*
	 *  æ‰«æå‘½ä»¤ï¼Œå¹¶æ ¹æ®éœ€æ±‚å¤„ç†æ¯ä¸ªå‘½ä»¤
	 *  é€šè¿‡ headersï¼Œè§£æ 4 é
	 *  0: ç¡®å®šTEXT(ä»£ç æ®µ)å’ŒDATA(æ•°æ®æ®µæ˜¯å¦é¡µé¢å¯¹é½
	 *  1: çº¿ç¨‹çŠ¶æ€ï¼Œuuidï¼Œä»£ç ç­¾å
	 *  2: segments
	 *  3: dyldï¼ŒåŠ å¯†ï¼Œæ£€æŸ¥å…¥å£ç‚¹
	 */

	boolean_t slide_realign = FALSE;
#if __arm64__
	if (!abi64) {
		slide_realign = TRUE;
	}
#endif

	for (pass = 0; pass <= 3; pass++) {
        /// å¦‚æœä¸éœ€è¦åšå¯¹é½æ ¡éªŒï¼Œç›´æ¥ä¸‹ä¸€è½®
		if (pass == 0 && !slide_realign && !is_dyld) {
			/* if we dont need to realign the slide or determine dyld's load
			 * address, pass 0 can be skipped */
			continue;
		} else if (pass == 1) {
#if __arm64__
			boolean_t       is_pie;
			int64_t         adjust;

			is_pie = ((header->flags & MH_PIE) != 0);
			if (pagezero_end != 0 &&
			    pagezero_end < effective_page_size) {
				/// è‡³å°‘éœ€è¦ä¸€ä¸ªé¡µé¢çš„PAGEZERO
				adjust = effective_page_size;
				MACHO_PRINTF(("pagezero boundary at "
				    "0x%llx; adjust slide from "
				    "0x%llx to 0x%llx%s\n",
				    (uint64_t) pagezero_end,
				    slide,
				    slide + adjust,
				    (is_pie
				    ? ""
				    : " BUT NO PIE ****** :-(")));
				if (is_pie) {
					slide += adjust;
					pagezero_end += adjust;
					executable_end += adjust;
					writable_start += adjust;
				}
			}
			if (pagezero_end != 0) {
				result->has_pagezero = TRUE;
			}
			if (executable_end == writable_start &&
			    (executable_end & effective_page_mask) != 0 &&
			    (executable_end & FOURK_PAGE_MASK) == 0) {
				/// TEXT / DATA æ®µæ˜¯4Kå¯¹é½çš„ï¼Œä½†ä¸æ˜¯é¡µé¢å¯¹é½çš„ã€‚è°ƒæ•´ slideä»¥ä½¿å…¶ä¸é¡µé¢å¯¹é½ï¼Œ
                /// å¹¶é¿å…é¡µé¢å…·æœ‰å†™å’Œæ‰§è¡Œæƒé™ã€‚
				adjust =
				    (effective_page_size -
				    (executable_end & effective_page_mask));
				MACHO_PRINTF(("page-unaligned X-W boundary at "
				    "0x%llx; adjust slide from "
				    "0x%llx to 0x%llx%s\n",
				    (uint64_t) executable_end,
				    slide,
				    slide + adjust,
				    (is_pie
				    ? ""
				    : " BUT NO PIE ****** :-(")));
				if (is_pie) {
					slide += adjust;
				}
			}
#endif /* __arm64__ */

			if (dyld_no_load_addr && binresult) {
                /// dyld Mach-OæœªæŒ‡å®šåŠ è½½åœ°å€ã€‚å…¶åœ°å€ = éšæœºåœ°å€ + æ–‡ä»¶æœ€å¤§çš„è™šæ‹Ÿåœ°å€
				slide = vm_map_round_page(slide + binresult->max_vm_addr, effective_page_mask);
			}
		}
        ...
		/// æ£€æŸ¥æŸäº›æ®µæ˜¯å¦æ˜ å°„äº†Mach-Oæ–‡ä»¶çš„å¼€å¤´ï¼ŒåŠ¨æ€åŠ è½½ç¨‹åºéœ€è¦æ­¤æ–‡ä»¶æ¥è¯»å–machæ ‡é¢˜ï¼Œç­‰ç­‰ã€‚
		if ((pass == 3) && (found_header_segment == FALSE)) {
			ret = LOAD_BADMACHO;
			break;
		}
		offset = mach_header_sz;
		ncmds = header->ncmds;
		while (ncmds--) {
			/* ç¡®ä¿è¶³å¤Ÿçš„ç©ºé—´å¯ä»¥è§£æ load_command */
			if (offset + sizeof(struct load_command) > cmds_size) {
				ret = LOAD_BADMACHO;
				break;
			}
			/// è·å–è¦è§£æçš„load_commandåœ°å€
			lcp = (struct load_command *)(addr + offset);
            /// oldoffsetæ˜¯ä»Mach-Oæ–‡ä»¶å†…å­˜å¼€å§‹çš„åœ°æ–¹åç§»åˆ°å½“å‰commandçš„åç§»é‡
			oldoffset = offset;
            /// é‡æ–°è®¡ç®—offsetï¼Œå†åŠ ä¸Šå½“å‰commandçš„é•¿åº¦ï¼Œoffsetçš„å€¼ä¸ºæ–‡ä»¶å†…å­˜èµ·å§‹åœ°å€åˆ°ä¸‹ä¸€ä¸ªcommandçš„åç§»é‡
            if (os_add_overflow(offset, lcp->cmdsize, &offset) ||
                    lcp->cmdsize < sizeof(struct load_command) ||
                    offset > cmds_size) {
                ret = LOAD_BADMACHO;
                break;
            }
            /// åšäº†ä¸€ä¸ªæ£€æµ‹ï¼Œä¸å¦‚ä½•åŠ è½½è¿›å…¥å†…å­˜æ— å…³
			switch (lcp->cmd) {
            ///  æŒ‡å¯¼å†…æ ¸å¦‚ä½•è®¾ç½®æ–°è¿è¡Œè¿›è¡Œçš„å†…å­˜ç©ºé—´ã€‚è¿™äº›æ®µç›´æ¥ä»Mach-OåŠ è½½åˆ°å†…å­˜ä¸­
			case LC_SEGMENT: {
				struct segment_command *scp = (struct segment_command *) lcp;
                ...
                /// segmentæ˜ å°„å’Œè§£æ
                /// segmentä¸‹è¿˜æœ‰åŒºçš„æ¦‚å¿µï¼Œæ¯”å¦‚__objc_classlistï¼Œ__objc_protolist
				ret = load_segment(lcp,
				    header->filetype,
				    control,
				    file_offset,
				    macho_size,
				    vp,
				    map,
				    slide,
				    result);
				....
				break;
			}
            /// æ˜ å°„æ–‡ä»¶ä¸­çš„ç‰¹å®šçš„å­—èŠ‚åˆ°è™šæ‹Ÿå†…å­˜
			case LC_SEGMENT_64: {
				struct segment_command_64 *scp64 = (struct segment_command_64 *) lcp;
                ...

				ret = load_segment(lcp,
				    header->filetype,
				    control,
				    file_offset,
				    macho_size,
				    vp,
				    map,
				    slide,
				    result);
                ...
				break;
			}
            /// UNIXçº¿ç¨‹ï¼ŒåŒ…å«å †æ ˆ
			case LC_UNIXTHREAD:
				if (pass != 1) {
					break;
				}
				ret = load_unixthread(
					(struct thread_command *) lcp,
					thread,
					slide,
					result);
				break;
            /// æ›¿æ¢LC_UNIXTHREAD
			case LC_MAIN:
                ...
                    
				ret = load_main(
					(struct entry_point_command *) lcp,
					thread,
					slide,
					result);
				break;
            /// åŠ è½½åŠ¨æ€é“¾æ¥å™¨
			case LC_LOAD_DYLINKER:
				if (pass != 3) {
					break;
				}
				if ((depth == 1) && (dlp == 0)) {
                    //// åŠ¨æ€è§£æå™¨åœ°å€
					dlp = (struct dylinker_command *)lcp;
					dlarchbits = (header->cputype & CPU_ARCH_MASK);
				} else {
					ret = LOAD_FAILURE;
				}
				break;
            /// UUID
			case LC_UUID:
				if (pass == 1 && depth == 1) {
					ret = load_uuid((struct uuid_command *) lcp,
					    (char *)addr + cmds_size,
					    result);
				}
				break;
            /// ä»£ç ç­¾å
			case LC_CODE_SIGNATURE:
				...
				ret = load_code_signature(
					(struct linkedit_data_command *) lcp,
					vp,
					file_offset,
					macho_size,
					header->cputype,
					result,
					imgp);
				....
				break;
#if CONFIG_CODE_DECRYPTION
            /// åŠ å¯†çš„æ®µä¿¡æ¯
			case LC_ENCRYPTION_INFO:
			case LC_ENCRYPTION_INFO_64:
				if (pass != 3) {
					break;
				}
				ret = set_code_unprotect(
					(struct encryption_info_command *) lcp,
					addr, map, slide, vp, file_offset,
					header->cputype, header->cpusubtype);
				...
				break;
#endif
    ...
	if (ret == LOAD_SUCCESS) {
        ...
		if ((ret == LOAD_SUCCESS) && (dlp != 0)) {
			/// åŠ è½½åŠ¨æ€è§£æå™¨.ä¸ç®¡ä¸»äºŒè¿›åˆ¶æ–‡ä»¶çš„PIEå¤§å°å¦‚ä½•dï¼Œéƒ½ä¼šå†è°ƒç”¨ä¸€æ¬¡ parse_machfile
			ret = load_dylinker(dlp, dlarchbits, map, thread, depth,
			    dyld_aslr_offset, result, imgp);
		}
		...
	}
    ...

	return ret;
}
```

ä¸Šé¢çš„è¿‡ç¨‹å¾—åˆ°çš„ç»“æœä¼šè¢«èµ‹å€¼è¿› `load_result_t` è¿™ä¸ªç»“æœä½“

```
typedef struct _load_result {
	user_addr_t		mach_header;
	user_addr_t		entry_point;

	// The user stack pointer and addressable user stack size.
	user_addr_t		user_stack;
	mach_vm_size_t		user_stack_size;

	// The allocation containing the stack and guard area.
	user_addr_t		user_stack_alloc;
	mach_vm_size_t		user_stack_alloc_size;

	mach_vm_address_t	all_image_info_addr;
	mach_vm_size_t		all_image_info_size;

	int			thread_count;
	unsigned int
		/* boolean_t */	unixproc	:1,
				needs_dynlinker 	:1,
				dynlinker			:1,
				validentry			:1,
				has_pagezero		:1,
				using_lcmain		:1,
#if __arm64__
				legacy_footprint	:1,
#endif /* __arm64__ */
				is_64bit_addr		:1,
				is_64bit_data		:1;
	unsigned int		csflags;
	unsigned char		uuid[16];
	mach_vm_address_t	min_vm_addr;
	mach_vm_address_t	max_vm_addr;
	unsigned int		platform_binary;
	off_t			cs_end_offset;
	void			*threadstate;
	size_t			threadstate_sz;
} load_result_t;
```

é‚£ä¹ˆåœ¨å“ªé‡Œè®¾ç½® `entry_point`ï¼Œå…¶å® `entry_point` çš„è®¾ç½®åœ¨ `load_dylinker` é‡Œ

```
static load_return_t load_dylinker {
	...
	ret = parse_machfile(vp, map, thread, header, file_offset,
	    macho_size, depth, slide, 0, myresult, result, imgp);

	if (ret == LOAD_SUCCESS) {
		if (result->threadstate) {
			/* don't use the app's threadstate if we have a dyld */
			kfree(result->threadstate, result->threadstate_sz);
		}
		result->threadstate = myresult->threadstate;
		result->threadstate_sz = myresult->threadstate_sz;

		result->dynlinker = TRUE;
        /// å°†load_result_tçš„entry_pointï¼Œè®¾ç½®ä¸ºdyldåŠ¨æ€é“¾æ¥åº“çš„entrypointï¼Œæ‰€ä»¥å¯åŠ¨çš„æ—¶å€™é¦–å…ˆåŠ è½½çš„ä¼šæ˜¯dyldã€‚
		result->entry_point = myresult->entry_point;
		result->validentry = myresult->validentry;
		result->all_image_info_addr = myresult->all_image_info_addr;
		result->all_image_info_size = myresult->all_image_info_size;
		if (myresult->platform_binary) {
			result->csflags |= CS_DYLD_PLATFORM;
		}
	}

	...
	return ret;
}
```

##### 2.2 activate_exec_state

`activate_exec_state` æºç çš„ç®€åŒ–åˆ†æ

```
static int activate_exec_state {
    ...
    /// è®¾ç½®å…¥å£ç‚¹
	thread_setentrypoint(thread, result->entry_point);
	return KERN_SUCCESS;
}
```

##### 2.3 å°æ®µæ€»ç»“

ä¸Šè¿°å‡½æ•°ä¸»è¦æ˜¯åŠ è½½å’Œè§£æ `Mach-O` ä¿¡æ¯ï¼Œå¹¶è®¾ç½®ç¨‹åºçš„ entry_pointã€‚

#### 3. app å¯åŠ¨çš„æµç¨‹

- execve() ï¼šç”¨æˆ·ç‚¹å‡»äº† appï¼Œç³»ç»Ÿè°ƒç”¨ execve() åˆ°å†…æ ¸
  - mac_execveï¼šforkä¸€æ¡æ–°çš„çº¿ç¨‹(è¿›ç¨‹)å‡ºæ¥
    - exec_activate_imageï¼šæ‰¾åˆ°äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå¹¶ç¡®å®šè§£æå‡½æ•°
      - exec_mach_imgactï¼šMach-O Binaryå’ŒFat Binaryéƒ½æœ‰å¯¹åº”çš„åŠ è½½å‡½æ•°ï¼Œæ­¤å‡½æ•°æ˜¯Mach-O Binaryçš„åŠ è½½å‡½æ•°ã€‚
        - load_machfileï¼šåŠ è½½ä¸»ç¨‹åºçš„Mach-Oä¿¡æ¯ã€‚
          - parse_machfileï¼šè§£æä¸»ç¨‹åºçš„Mach-Oä¿¡æ¯
            - load_dylinkerï¼š è§£æå®Œ machoåï¼Œæ ¹æ®machoä¸­çš„ LC_LOAD_DYLINKER è¿™ä¸ªLoadCommandæ¥å¯åŠ¨è¿™ä¸ªäºŒè¿›åˆ¶çš„åŠ è½½å™¨ï¼Œå³ /usr/bin/dyld
            - parse_machfileï¼šè§£æ dyld è¿™ä¸ªMach-Oæ–‡ä»¶ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­ä¼šè§£æå‡ºentry_point
        - activate_exec_stateï¼š
          - thread_setentrypointï¼š è®¾ç½®entry_pointã€‚

  - è¿›å…¥entry_pointå¯¹åº”çš„å…¥å£ï¼Œå¯åŠ¨dyld

å¯¹åº”çš„æµç¨‹å›¾ï¼š
![image-20200604113902874](http://blog.objccf.com/blog/2020-06-04-033903.png)



>è¿™ä¸ª `entry_point` å°±æ˜¯ `_dyld_start `çš„åœ°å€ï¼Œä¸ºä»€ä¹ˆï¼Ÿå‚è€ƒæ–‡ç« ï¼š[_dyld_startä¹‹å‰](https://blog.cnbluebox.com/blog/2017/06/30/dyld2/)

### 0x06 dyldåŠ è½½ç¨‹åºæµç¨‹

#### 1. __dyld_start

ä¸Šé¢åœ¨æœ€åä¸€æ¬¡åŠ è½½å®Œ `dyld` åï¼Œå°±è¿›å…¥ `dyld` çš„å…¥å£å‡½æ•°ï¼Œå³ `__dyld_start`ï¼Œåœ¨ `dyld` æºç ä¸­ï¼Œ`__dyld_start` ç”¨æ±‡ç¼–å®ç°ï¼Œä¸‹é¢æ˜¯å…¶ `__arm64__` çš„å®ç°ï¼š

```
#if __arm64__
	.text
	.align 2
	.globl __dyld_start
__dyld_start:
	mov 	x28, sp
	and     sp, x28, #~15		// å¼ºåˆ¶å †æ ˆçš„ 16 å­—èŠ‚å¯¹é½
	mov	x0, #0
	mov	x1, #0
	stp	x1, x0, [sp, #-16]!	// å¯¹é½ terminating frame
	mov	fp, sp			// è®¾ç½® fp æŒ‡å‘ terminating frame
	sub	sp, sp, #16             // ä¸ºå±€éƒ¨å˜é‡è…¾å‡ºç©ºé—´
#if __LP64__
	ldr     x0, [x28]               // è·å–ä¸»ç¨‹åºçš„ mach_header
	ldr     x1, [x28, #8]           // å°†ä¸Šä¸ªå‡½æ•°ä¼ å…¥çš„ argc èµ‹å€¼ç»™ x1(å†…æ ¸å°†32ä½int argcä½œä¸º64ä½å †æ ˆä¼ é€’ï¼‰ä»¥ä¿æŒå¯¹é½çŠ¶æ€
	add     x2, x28, #16            // å°†ä¸Šä¸ªå‡½æ•°ä¼ å…¥çš„ argv èµ‹å€¼ç»™ x2
#endif
	adrp	x3,___dso_handle@page
	add 	x3,x3,___dso_handle@pageoff // è·å– dyld çš„ mach_headerget
	mov	x4,sp                   // x5 has &startGlue
	
	/// å¯åŠ¨å¼•å¯¼ï¼Œå…¥å£ä¸ºdyldbootstrap::startå‡½æ•°

	/// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &startGlue)
	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm
	/// ä¼šè¿”å›ä¸»ç¨‹åºçš„å…¥å£åœ°å€ï¼Œå¹¶ä¿å­˜åˆ°x16å¯„å­˜å™¨
	mov	x16,x0                  // save entry point address in x16
#if __LP64__
	ldr     x1, [sp]
#endif
	cmp	x1, #0
	b.ne	Lnew

	/// å½“æ‰€æœ‰åº“éƒ½å®ŒæˆåŠ è½½ä¹‹åï¼Œdyldçš„å·¥ä½œä¹Ÿå®Œæˆäº†ï¼Œä¹‹åç”±LC_UNIXTHREADå‘½ä»¤è´Ÿè´£å¯åŠ¨äºŒè¿›åˆ¶ç¨‹åºçš„ä¸»çº¿ç¨‹
	// LC_UNIXTHREAD way, clean up stack and jump to result
#if __LP64__
	add	sp, x28, #8             // restore unaligned stack pointer without app mh
#endif
    /// è·³è½¬åˆ°ç¨‹åºçš„å…¥å£ç‚¹
#if __arm64e__
	braaz   x16                     // jump to the program's entry point
#else
	br      x16                     // jump to the program's entry point
#endif
	/// è®¾ç½®ç¨‹åºä¸»çº¿ç¨‹çš„å…¥å£åœ°å€å’Œæ ˆå¤§å°ï¼Œç”¨æ¥è°ƒç”¨ main()
	// LC_MAIN case, set up stack for call to main()
Lnew:	mov	lr, x1		    // simulate return address into _start in libdyld.dylib
#if __LP64__
	ldr	x0, [x28, #8]       // main param1 = argc ï¼šmain ç¬¬ä¸€ä¸ªå‚æ•°
	add	x1, x28, #16        // main param2 = argv ï¼šmain ç¬¬äºŒä¸ªå‚æ•°
	add	x2, x1, x0, lsl #3
	add	x2, x2, #8          // main param3 = &env[0] ï¼šmain ç¬¬ä¸‰ä¸ªå‚æ•°
	mov	x3, x2
Lapple:	ldr	x4, [x3]
	add	x3, x3, #8
#endif
	cmp	x4, #0
	b.ne	Lapple		    // main param4 = apple ï¼šmain ç¬¬å››ä¸ªå‚æ•°
	/// è°ƒç”¨ main()
#if __arm64e__
	braaz   x16
#else
	br      x16
#endif

#endif // __arm64__
```

ä¸Šè¿°æºç ï¼Œä¸»è¦æ˜¯è·å–ä¸»ç¨‹åºå’Œ `dyld` çš„ `mach_header`ï¼Œä¹‹åè°ƒç”¨å‡½æ•° `dyldbootstrap::start` å¯¹ä¸»ç¨‹åºè¿›ä¸€æ­¥å¤„ç†ï¼Œå¤„ç†å®Œä¹‹åè¿”å›ä¸»ç¨‹åºçš„å…¥å£åœ°å€ï¼Œç„¶åè®¾ç½®å…¶æ‰€éœ€å‚æ•°ï¼Œè°ƒç”¨ `main()`ï¼Œè¿›å…¥ä¸»ç¨‹åºã€‚ä¸‹é¢å¼€å§‹å¯¹ `dyldbootstrap::start` è¿›è¡Œåˆ†æã€‚

#### 2. dyldbootstrap::start

ä¸‹é¢æ˜¯å‡½æ•° `dyldbootstrap::start` çš„ç®€åŒ–æºç åˆ†æã€‚

```
uintptr_t start(const dyld3::MachOLoaded* appsMachHeader, int argc, const char* argv[],
				const dyld3::MachOLoaded* dyldsMachHeader, uintptr_t* startGlue)
{

    /// å‘å‡º kdebug è·Ÿè¸ªï¼Œé¢„ç¤ºç€ å¼•å¯¼ç¨‹åºå·²ç»å¯åŠ¨
    // Emit kdebug tracepoint to indicate dyld bootstrap has started <rdar://46878536>
    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, 0, 0, 0, 0);

	/// å¦‚æœå†…æ ¸æœ‰ slide dyld, æˆ‘ä»¬å¿…é¡» fixeup ä¸€ä¸‹dylyä¸­çš„å†…å®¹.
    rebaseDyld(dyldsMachHeader);
	/// å†…æ ¸è®¾ç½®çš„env pointers, ä¹Ÿå°±æ˜¯ç¯å¢ƒå‚æ•°
	const char** envp = &argv[argc+1];
    ...
	// ä¸ºå †æ ˆè®¾ç½®éšæœºå€¼
	__guard_setup(apple);

#if DYLD_INITIALIZER_SUPPORT
	// run all C++ initializers inside dyld
    /// è¿™å¥è¯æ˜¯å…³é”®ï¼Œdyldåœ¨åˆå§‹åŒ–å…¶ä»–åº“ä¹‹å‰ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥è°ƒç”¨åº“è‡ªèº«çš„æ‰€æœ‰å…¨å±€C++å¯¹è±¡çš„åˆå§‹åŒ–å‡½æ•°ã€‚
	runDyldInitializers(argc, argv, envp, apple);
#endif
    /// å¼•å¯¼å®Œæˆï¼Œè°ƒç”¨ dyld çš„ main å‡½æ•°ï¼Œå»åˆå§‹åŒ–å¯æ‰§è¡Œç¨‹åºåŠåŠ è½½æ‰€æœ‰çš„åŠ¨æ€åº“
	// now that we are done bootstrapping dyld, call dyld's main
	uintptr_t appsSlide = appsMachHeader->getSlide();
	return dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);
}
```

ä¸Šè¿°æºç ä¸»è¦æ˜¯å¯åŠ¨å¼•å¯¼ç¨‹åºï¼Œè®¾ç½®å†…æ ¸ç¯å¢ƒå‚æ•°ï¼Œè°ƒç”¨ `dyld` çš„ `main` å‡½æ•°ï¼Œå»æ‰§è¡Œåˆå§‹åŒ–å’ŒåŠ è½½æ‰€æœ‰çš„åŠ¨æ€åº“ç­‰ã€‚ä¸‹é¢å¼€å§‹åˆ†æ `dyld::_main`ã€‚

#### 3. dyld::_main

ä¸‹é¢æ˜¯ `dyld::_main` å‡½æ•°çš„ç®€åŒ–å®ç°ï¼š

```
uintptr_t
_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, 
		int argc, const char* argv[], const char* envp[], const char* apple[], 
		uintptr_t* startGlue)
{
	...
	/// ä¿å­˜ä¸»ç¨‹åºçš„ mach_header
	sMainExecutableMachHeader = mainExecutableMH;
	sMainExecutableSlide = mainExecutableSlide;
	...
	
	/// 1. è®¾ç½®ä¸Šä¸‹æ–‡è¿è¡Œç¯å¢ƒ
	setContext(mainExecutableMH, argc, argv, envp, apple);

	/// è·å–å¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„
	sExecPath = _simple_getenv(apple, "executable_path");
	
	/// 2. é…ç½®è¿›ç¨‹é™åˆ¶ç›¸å…³ã€æ£€æŸ¥ç¯å¢ƒå˜é‡
    configureProcessRestrictions(mainExecutableMH, envp);
    checkEnvironmentVariables(envp);
	...
	/// è·å–å½“å‰è®¾å¤‡çš„ CPU æ¶æ„ä¿¡æ¯
	getHostInfo(mainExecutableMH, mainExecutableSlide);

	/// 3. æ£€æŸ¥æ˜¯å¦å¼€å¯å…±äº«ç¼“å­˜ï¼Œå¹¶åŠ è½½å…±äº«ç¼“å­˜åº“
	checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);
	if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) {
#if TARGET_OS_SIMULATOR
		if ( sSharedCacheOverrideDir)
			mapSharedCache();
#else
		mapSharedCache();
#endif
	}
	...

	// æ³¨å†Œ gdb é€šçŸ¥ï¼Œç”¨äºè°ƒè¯•ã€‚
	stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)->push_back(notifyGDB);
	stateToHandlers(dyld_image_state_mapped, sSingleHandlers)->push_back(updateAllImages);
	// make initial allocations large enough that it is unlikely to need to be re-alloced
	sImageRoots.reserve(16);
	sAddImageCallbacks.reserve(4);
	sRemoveImageCallbacks.reserve(4);
	sAddLoadImageCallbacks.reserve(4);
	sImageFilesNeedingTermination.reserve(16);
	sImageFilesNeedingDOFUnregistration.reserve(8);
	...
	/// åˆå§‹åŒ–ä¸»ç¨‹åº
	try {
		// 4 æ·»åŠ  dyld åˆ° UUID list
		addDyldImageToUUIDList();

		CRSetCrashLogMessage(sLoadingCrashMessage);
		
		/// 5. åŠ è½½ sExecPath è·¯å¾„ä¸‹çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œç”Ÿæˆä¸€ä¸ª ImageLoader å¯¹è±¡
		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);
		/// è®¾ç½®ä¸Šä¸‹æ–‡ï¼Œå°† ImageLoader å¯¹è±¡è®¾ç½®ç»™é“¾æ¥ä¸Šä¸‹æ–‡çš„ä¸»ç¨‹åºç›¸å…³å±æ€§ï¼Œå¹¶è®¾ç½®å…¶ç­¾åç›¸å…³ä¿¡æ¯
		gLinkContext.mainExecutable = sMainExecutable;
		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);
		...
		
		/// 6. ç°åœ¨å·²åŠ è½½å…±äº«ç¼“å­˜ï¼Œæ£€æŸ¥åº“çš„ç‰ˆæœ¬æ˜¯å¦æœ‰æ›´æ–°ï¼Œæœ‰åˆ™è¦†ç›–åŸæœ‰çš„
	#if SUPPORT_VERSIONED_PATHS
		checkVersionedPaths();
	#endif
		...
		/// 7. åŠ è½½ä»»ä½•æ’å…¥çš„åº“
		if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) {
			for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) 
				loadInsertedDylib(*lib);
		}
		
		/// è®°å½•æ’å…¥åº“çš„æ•°é‡ï¼Œä»¥ä¾¿è¿›è¡Œæœç´¢ï¼Œé¡ºåºæ˜¯ï¼Œå·®å…¥åº“ï¼Œmainï¼Œå…¶ä»–
		sInsertedDylibCount = sAllImages.size()-1;

		// 8. é“¾æ¥ä¸»ç¨‹åº
		gLinkContext.linkingMainExecutable = true;
#if SUPPORT_ACCELERATE_TABLES
		if ( mainExcutableAlreadyRebased ) {
			/// åœ¨é“¾æ¥ä¹‹ç¨‹åºä¹‹å‰ï¼Œå·²ä¸ºå…¶ ASLR è°ƒæ•´äº†å†…éƒ¨æŒ‡é’ˆï¼Œè¿™é‡Œé€šè¿‡ å rebasing æ¥è§£å†³
			sMainExecutable->rebase(gLinkContext, -mainExecutableSlide);
		}
#endif
		// å¼€å§‹é“¾æ¥ä¸»ç¨‹åº, æ­¤æ—¶ä¸»ç¨‹åºå·²ç»è¢«åŠ è½½åˆ° gLinkContext.mainExecutable ä¸­, è°ƒç”¨ link é“¾æ¥ä¸»ç¨‹åºã€‚å†…æ ¸è°ƒç”¨çš„æ˜¯ImageLoader::link å‡½æ•°ã€‚
		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);
		sMainExecutable->setNeverUnloadRecursive();
		if ( sMainExecutable->forceFlat() ) {
			gLinkContext.bindFlat = true;
			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;
		}

		// 9. é“¾æ¥æ‰€æœ‰æ’å…¥çš„åº“
		// åœ¨é“¾æ¥ä¸»ç¨‹åºä¹‹åæ‰§è¡Œæ”¹æ“ä½œï¼Œä»¥ä¾¿å¯ä»¥æ’å…¥æ›´å¤šçš„åº“
		// dylibs (e.g. libSystem) ä¸åœ¨ç¨‹åºä½¿ç”¨çš„ dylibs ä¹‹å‰é“¾æ¥
		if ( sInsertedDylibCount > 0 ) {
			for(unsigned int i=0; i < sInsertedDylibCount; ++i) {
				ImageLoader* image = sAllImages[i+1];
				link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);
				image->setNeverUnloadRecursive();
			}
			/// åªæœ‰æ’å…¥çš„åº“å¯ä»¥è°ƒç”¨
			/// æ³¨å†Œç¬¦å·æ’å…¥,Interposition, æ˜¯é€šè¿‡ç¼–å†™ä¸å‡½æ•°åº“åŒåçš„å‡½æ•°æ¥å–ä»£å‡½æ•°åº“çš„è¡Œä¸º.
			for(unsigned int i=0; i < sInsertedDylibCount; ++i) {
				ImageLoader* image = sAllImages[i+1];
				image->registerInterposing(gLinkContext);
			}
		}

		// <rdar://problem/19315404> dyld should support interposition even without DYLD_INSERT_LIBRARIES
		/// å³ä½¿æ²¡æœ‰DYLD_INSERT_LIBRARIESï¼Œdyldä¹Ÿåº”æ”¯æŒæ³¨å†Œç¬¦å·æ’å…¥
		for (long i=sInsertedDylibCount+1; i < sAllImages.size(); ++i) {
			ImageLoader* image = sAllImages[i];
			if ( image->inSharedCache() )
				continue;
			image->registerInterposing(gLinkContext);
		}
		
			// apply interposing to initial set of images
		for(int i=0; i < sImageRoots.size(); ++i) {
			sImageRoots[i]->applyInterposing(gLinkContext);
		}
		ImageLoader::applyInterposingToDyldCache(gLinkContext)
		...
		
		// 10. æ‰§è¡Œå¼±ç¬¦å·ç»‘å®š: ä»…åœ¨é“¾æ¥æ‰€æœ‰æ’å…¥çš„imagesåæ‰æ‰§è¡Œå¼±ç¬¦å·ç»‘å®š
		sMainExecutable->weakBind(gLinkContext);
		gLinkContext.linkingMainExecutable = false;

		sMainExecutable->recursiveMakeDataReadOnly(gLinkContext);
		
		///  11. åˆå§‹åŒ–ä¸»ç¨‹åº
		initializeMainExecutable(); 

		/// 12. æŸ¥æ‰¾ä¸»ç¨‹åºå¯æ‰§è¡Œæ–‡ä»¶çš„å…¥å£ç‚¹
		result = (uintptr_t)sMainExecutable->getEntryFromLC_MAIN();
		if ( result != 0 ) {
			// main executable uses LC_MAIN, we need to use helper in libdyld to call into main()
			if ( (gLibSystemHelpers != NULL) && (gLibSystemHelpers->version >= 9) )
				*startGlue = (uintptr_t)gLibSystemHelpers->startGlueToCallExit;
			else
				halt("libdyld.dylib support not present for LC_MAIN");
		}
		else {
			// main executable uses LC_UNIXTHREAD, dyld needs to let "start" in program set up for main()
			result = (uintptr_t)sMainExecutable->getEntryFromLC_UNIXTHREAD();
			*startGlue = 0;
			}
#if __has_feature(ptrauth_calls)
		/// startï¼ˆï¼‰å°†ç»“æœæŒ‡é’ˆä½œä¸ºå‡½æ•°æŒ‡é’ˆè°ƒç”¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¯¹å…¶è¿›è¡Œç­¾åã€‚
		result = (uintptr_t)__builtin_ptrauth_sign_unauthenticated((void*)result, 0, 0);
#endif
	}
	catch(const char* message) {
		...
	}
	catch(...) {
		....
	}
	...
	
	return result;
}
```

è¯¥å‡½æ•°çš„ä½œç”¨å¤§è‡´å¦‚ä¸‹ï¼š

- è®¾ç½®è¿è¡Œç¯å¢ƒï¼Œå¤„ç†ç¯å¢ƒå˜é‡
- é…ç½®è¿›ç¨‹é™åˆ¶ç›¸å…³ã€æ£€æŸ¥ç¯å¢ƒå˜é‡
- æ£€æŸ¥æ˜¯å¦å¼€å¯å…±äº«ç¼“å­˜ï¼Œå¹¶åŠ è½½å…±äº«ç¼“å­˜åº“
- æ·»åŠ  dyldè‡ªèº« åˆ° UUID list
- åˆå§‹åŒ–ä¸»ç¨‹åºï¼Œä½ä¸»ç¨‹åºæˆåŠŸä¸€ä¸ª ImageLoader å¯¹è±¡
- æ£€æŸ¥åº“çš„ç‰ˆæœ¬æ˜¯å¦æœ‰æ›´æ–°ï¼Œæœ‰åˆ™è¦†ç›–åŸæœ‰çš„
- åŠ è½½ä»»ä½•æ’å…¥çš„åº“
- é“¾æ¥ä¸»ç¨‹åº
- é“¾æ¥æ‰€æœ‰æ’å…¥çš„åº“
- æ‰§è¡Œå¼±ç¬¦å·ç»‘å®š: ä»…åœ¨é“¾æ¥æ‰€æœ‰æ’å…¥çš„imagesåæ‰æ‰§è¡Œå¼±ç¬¦å·ç»‘å®š
- åˆå§‹åŒ–ä¸»ç¨‹åº
- æŸ¥æ‰¾ä¸»ç¨‹åºå¯æ‰§è¡Œæ–‡ä»¶çš„å…¥å£ç‚¹

##### 3.1 è®¾ç½®è¿è¡Œç¯å¢ƒï¼Œå¤„ç†ç¯å¢ƒå˜é‡

åˆšå¼€å§‹å…ˆæŠŠ ä¸»ç¨‹åºçš„ `mach_header` èµ‹å€¼ç»™ `sMainExecutableMachHeader`ã€‚ç„¶åæ‰§è¡Œ `setContext(..)`ï¼Œå…¶æ¥æ”¶å‚æ•°æ˜¯ `ä¸»ç¨‹åº mach_hader`ã€`argc`ã€`argv`ã€`envp`ã€`appl`eã€‚æ­¤å‡½æ•°è®¾ç½®äº†ä¸€ä¸ªå…¨å±€çš„é“¾æ¥ä¸Šä¸‹æ–‡ `gLinkContext`ã€ç¯å¢ƒå˜é‡ã€å›è°ƒå‡½æ•°ã€é“¾æ¥ `imageCount`ã€ä¸»ç¨‹åº `mach_hader`ã€`loadLibrary`ç­‰ã€‚`loadLibrary` å¯¹åº”æœ¬æ¨¡å—çš„ `libraryLocator()` æ–¹æ³•, è´Ÿè´£åŠ è½½åŠ¨æ€åº“ã€‚

##### 3.2 é…ç½®è¿›ç¨‹é™åˆ¶ç›¸å…³ã€æ£€æŸ¥ç¯å¢ƒå˜é‡

å¦‚æœè¿›ç¨‹æ”¶åˆ°é™åˆ¶ï¼Œå¤„ç†ç¯å¢ƒå˜é‡å‘ç”Ÿæ”¹å˜ï¼Œä¼šè¿›è¡Œä¸‹é¢æ“ä½œï¼š

- æ›´æ–° `gLinkContext` çš„ç›¸å…³å˜é‡ï¼šä¸»è¦æ˜¯ç”±äºç¯å¢ƒå˜é‡å‘ç”Ÿå˜åŒ–äº†, éœ€è¦æ›´æ–°è¿›ç¨‹çš„envpä¸è·¯å¾„ç›¸å…³å‚æ•°ã€‚

- `checkEnvironmentVariables()`ï¼šæ£€æŸ¥ç¯å¢ƒå˜é‡

   å¦‚æœ `gLinkContext.allowEnvVarsPath` ä¸ `gLinkContextã€‚allowEnvVarsPrint` ä¸ºç©ºï¼Œç›´æ¥è·³è¿‡ï¼Œå¦åˆ™è°ƒç”¨ `processDyldEnvironmentVariable()` å¤„ç†å¹¶è®¾ç½®ç¯å¢ƒå˜é‡ã€‚ç„¶åè°ƒç”¨  `checkLoadCommandEnvironmentVariables()` å»æ£€æŸ¥ ä¸»ç¨‹åºçš„ `mach_hadner` çš„ `ncmds` å»æ£€æŸ¥ç¯å¢ƒå˜é‡ã€‚

  - `processDyldEnvironmentVariable()`ï¼šå¯¹ä¸åŒçš„ç¯å¢ƒå˜é‡åšç›¸åº”çš„å¤„ç†ã€‚
  - `checkLoadCommandEnvironmentVariables()`ï¼šéå† `Mach-O` ä¸­æ‰€æœ‰çš„ `LC_DYLD_ENVIRONMENT` åŠ è½½å‘½ä»¤ï¼Œç„¶åè°ƒç”¨ `processDyldEnvironmentVariable()`ã€‚

##### 3.3 æ£€æŸ¥æ˜¯å¦å¼€å¯å…±äº«ç¼“å­˜ï¼Œå¹¶åŠ è½½å…±äº«ç¼“å­˜åº“

###### 3.3.1 æ£€æŸ¥æ˜¯å¦å¼€å¯å…±äº«ç¼“å­˜

`checkSharedRegionDisable`ï¼šæ£€æŸ¥æ˜¯å¦å¼€å¯å…±äº«ç¼“å­˜ï¼ŒiOS å¹³å°ç”¨ä¸ç¦ç”¨ã€‚

###### 3.3.2 åŠ è½½å…±äº«ç¼“å­˜åº“

>  å…±äº«ç¼“å­˜åº“ï¼šæ˜¯ `dyld` æ”¯æŒçš„å¦å¤–ä¸€ç§æœºåˆ¶ã€‚å…±äº«ç¼“å­˜åº“æŒ‡çš„æ˜¯ä¸€äº›åº“ç»è¿‡é¢„å…ˆé“¾æ¥ï¼Œç„¶åä¿å­˜åˆ°ç£ç›˜ä¸Šçš„ä¸€ä¸ªæ–‡ä»¶ä¸­ã€‚åœ¨ iOS ä¸­ï¼Œå…±äº«ç¼“å­˜åº“å¯ä»¥åœ¨ `/System/Library/Caches/com/apple.dyld` ä¸­æ‰¾åˆ° ã€‚å¦‚ `libdispatch`ï¼Œ`UIKit` éƒ½æ˜¯å…±äº«ç¼“å­˜åº“ã€‚

è¿™ä¸€æ­¥ä¸»è¦æ˜¯è°ƒç”¨ `mapSharedCache()` æ¥æ˜ å°„å…±äº«ç¼“å­˜åº“ã€‚ä¸‹é¢æ˜¯å…¶æºç çš„ç®€åŒ–åˆ†æï¼š

```
bool loadDyldCache(const SharedCacheOptions& options, SharedCacheLoadInfo* results)
{
    ...
    if ( options.forcePrivate ) {
        /// ä»…åŠ è½½åˆ°å½“å‰è¿›ç¨‹
        return mapCachePrivate(options, results);
    }
    else {
        // fast path: when cache is already mapped into shared region
        bool hasError = false;
        /// å¿«æ·è·¯å¾„ï¼šå·²ç»æ˜ å°„åˆ°äº†å…±äº«åŒºåŸŸäº†ï¼Œç›´æ¥å°†å®ƒåœ¨å…±äº«å†…å­˜ä¸­çš„å†…å­˜åœ°å€æ˜ å°„åˆ°è¿›ç¨‹çš„å†…å­˜åœ°å€ç©ºé—´
        /// å…¶å®è¯´ç™½äº†ï¼Œå°±æ˜¯ä¹‹å‰å·²ç»åŠ è½½è¿‡
        if ( reuseExistingCache(options, results) ) {
            hasError = (results->errorMessage != nullptr);
        } else {
            /// æ…¢è·¯å¾„ï¼šå¦‚æœæ˜¯ç¬¬ä¸€ä¸ªç¨‹åºåˆšåˆšå¯åŠ¨ï¼Œå…±äº«åŒºå…¶å®æ²¡å†…å®¹çš„ï¼Œéœ€è¦å°†åº“æ˜ å°„åˆ°å…±äº«åŒº
            /// ç¬¬ä¸€æ¬¡åŠ è½½
            hasError = mapCacheSystemWide(options, results);
        }
        return hasError;
    }
}
```

è¯¥å‡½æ•°è°ƒç”¨æœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š

- å½“è¿™ä¸ªåº“è¢« `forcePrivate` çš„æƒ…å†µä¸‹ï¼Œä»…åŠ è½½åˆ°å½“å‰è¿›ç¨‹ä¸­ã€‚
- å…±äº«ç¼“å­˜åº“ç¬¬ä¸€æ¬¡åŠ è½½ï¼Œè°ƒç”¨æ–¹æ³• `mapCacheSystemWide()`ã€‚
- å…±äº«ç¼“å­˜åº“ä¹‹å‰è¢«åŠ è½½è¿‡ï¼Œç›´æ¥å°†å®ƒåœ¨ `å…±äº«å†…å­˜ `ä¸­çš„`å†…å­˜åœ°å€`æ˜ å°„åˆ°è¿›ç¨‹çš„`å†…å­˜åœ°å€`ä¸­ã€‚

**mapCacheSystemWide()**

```
static bool mapCacheSystemWide(const SharedCacheOptions& options, SharedCacheLoadInfo* results)
{
    CacheInfo info;
    /// é¢„æ£€æµ‹ç¼“å­˜æ–‡ä»¶
    if ( !preflightCacheFile(options, results, &info) )
        return false;
    ...
    /// ä½¿ç”¨è¯¥æ–¹æ³•å®Œæˆæ˜ å°„
    int result = __shared_region_map_and_slide_np(info.fd, 3, info.mappings, results->slide, slideInfo, info.slideInfoSize);
    ...
    return true;
}

static bool preflightCacheFile(const SharedCacheOptions& options, SharedCacheLoadInfo* results, CacheInfo* info)
{
    
    /// æŸ¥æ‰¾å¹¶æ‰“å¼€å…±äº«ç¼“å­˜åº“æ–‡ä»¶
    int fd = openSharedCacheFile(options, results);
    
    struct stat cacheStatBuf;
    /// å…±äº«ç¼“å­˜åº“ç»Ÿè®¡å¤±è´¥
    if ( dyld::my_stat(results->path, &cacheStatBuf) != 0 ) {
        results->errorMessage = "shared cache file stat() failed";
        ::close(fd);
        return false;
    }

    // åˆç†æ€§çš„æ£€æŸ¥ header å’Œ æ˜ å°„
    uint8_t firstPage[0x4000];
    if ( ::pread(fd, firstPage, sizeof(firstPage), 0) != sizeof(firstPage) ) {
        results->errorMessage = "shared cache file pread() failed";
        ::close(fd);
        return false;
    }
    /// è§£æ dyld_cache_header ä¿¡æ¯
    const dyld_cache_mapping_info* const fileMappings = (dyld_cache_mapping_info*)&firstPage[cache->header.mappingOffset];
    
    ...
    // ç¼“å­˜æ–‡ä»¶çš„ä»£ç ç­¾ååŠéªŒè¯ç­¾å
    fsignatures_t siginfo;
    siginfo.fs_file_start = 0;  // cache always starts at beginning of file
    siginfo.fs_blob_start = (void*)cache->header.codeSignatureOffset;
    siginfo.fs_blob_size  = (size_t)(cache->header.codeSignatureSize);
    ...
    
    // è§£æå¥½çš„ç¼“å­˜ä¿¡æ¯å­˜å…¥åˆ° mappings å˜é‡
    info->fd = fd;
    for (int i=0; i < 3; ++i) {
        info->mappings[i].sfm_address       = fileMappings[i].address;
        info->mappings[i].sfm_size          = fileMappings[i].size;
        info->mappings[i].sfm_file_offset   = fileMappings[i].fileOffset;
        info->mappings[i].sfm_max_prot      = fileMappings[i].maxProt;
        info->mappings[i].sfm_init_prot     = fileMappings[i].initProt;
    }
    info->mappings[1].sfm_max_prot  |= VM_PROT_SLIDE;
    info->mappings[1].sfm_init_prot |= VM_PROT_SLIDE;
    info->slideInfoAddressUnslid  = fileMappings[2].address + cache->header.slideInfoOffset - fileMappings[2].fileOffset;
    info->slideInfoSize           = (long)cache->header.slideInfoSize;
    if ( cache->header.mappingOffset >= 0xf8 ) {
        info->sharedRegionStart = cache->header.sharedRegionStart;
        info->sharedRegionSize  = cache->header.sharedRegionSize;
        info->maxSlide          = cache->header.maxSlide;
    }
    else {
        info->sharedRegionStart = SHARED_REGION_BASE;
        info->sharedRegionSize  = SHARED_REGION_SIZE;
        info->maxSlide          = SHARED_REGION_SIZE - (fileMappings[2].address + fileMappings[2].size - fileMappings[0].address);
    }
    return true;
}
```

é¦–å…ˆè°ƒç”¨ `preflightCacheFile()` æ–¹æ³•å»æ£€æµ‹ç¼“å­˜ç¯å¢ƒï¼Œåœ¨å…¶å‡½æ•°ä¸­ä¼šè°ƒç”¨ `openSharedCacheFile()` å»æ‰“å¼€ç¼“å­˜æ–‡ä»¶ï¼Œæ‰“å¼€ä¸ç³»ç»Ÿå½“å‰ `CPU` æ¶æ„åŒ¹é…çš„ç¼“å­˜æ–‡ä»¶ï¼Œæ£€æŸ¥ `header` å’Œæ˜ å°„ã€è§£æ `dyld_cache_header` ä¿¡æ¯ï¼Œåœ¨å¯¹ç¼“å­˜æ–‡ä»¶è¿›è¡Œç­¾åå’ŒéªŒè¯ï¼ŒæŠŠè§£æå¥½çš„æ•°æ® `fileMappings` å’Œ `dyld_cache_header` ä¿¡æ¯å­˜å…¥åˆ° `mappings `ç­‰å˜é‡ä¸­ã€‚æœ€å `__shared_region_map_and_slide_np()` å®ŒæˆçœŸæ­£çš„æ˜ å°„å·¥ä½œã€‚

##### 3.4 æ·»åŠ  dyld åˆ° UUID list

```
static void addDyldImageToUUIDList()
{
	const struct macho_header* mh = (macho_header*)&__dso_handle;
	const uint32_t cmd_count = mh->ncmds;
	const struct load_command* const cmds = (struct load_command*)((char*)mh + sizeof(macho_header));
	const struct load_command* cmd = cmds;
	for (uint32_t i = 0; i < cmd_count; ++i) {
		switch (cmd->cmd) {
			case LC_UUID: {
				uuid_command* uc = (uuid_command*)cmd;
				dyld_uuid_info info;
				info.imageLoadAddress = (mach_header*)mh;
				memcpy(info.imageUUID, uc->uuid, 16);
				addNonSharedCacheImageUUID(info);
				return;
			}
		}
		cmd = (const struct load_command*)(((char*)cmd)+cmd->cmdsize);
	}
}

void addNonSharedCacheImageUUID(const dyld_uuid_info& info)
{
	/// å°†uuidArrayè®¾ç½®ä¸ºNULLè¡¨ç¤ºå®ƒæ­£åœ¨ä½¿ç”¨
	dyld::gProcessInfo->uuidArray = NULL;
	
	// é™„åŠ æ‰€æœ‰æ–°image
	sImageUUIDs.push_back(info);
	dyld::gProcessInfo->uuidArrayCount = sImageUUIDs.size();
	
	// å°†uuidArrayè®¾ç½®å›å‘é‡çš„åŸºåœ°å€ï¼ˆå…¶ä»–è¿›ç¨‹ç°åœ¨å¯ä»¥è¯»å–ï¼‰
	dyld::gProcessInfo->uuidArray = &sImageUUIDs[0];
}
```

å…ˆé€šè¿‡å¾ªç¯ `load_command`ï¼Œæ‰¾åˆ°è‡ªèº« `UUID`ï¼Œç„¶åè°ƒç”¨ `memcpy`ï¼Œå¤åˆ¶è‡ªèº« `UUID` åˆ° å½“å‰ç¨‹åºçš„ `info.imageUUID` å¤„ï¼Œç„¶åè°ƒç”¨æ–¹æ³• `addNonSharedCacheImageUUID()` æŠŠè‡ªèº« `dyld` çš„ `UUID` æ·»åŠ åˆ°å…±äº«ç¼“å­˜åº“çš„ `UUID` åˆ—è¡¨ä¸­ã€‚

##### 3.5 åˆå§‹åŒ–ä¸»ç¨‹åºï¼Œä¸ºä¸»ç¨‹åºæˆåŠŸä¸€ä¸ª ImageLoader å¯¹è±¡

é€šè¿‡è°ƒç”¨ `instantiateFromLoadedImage()` æ–¹æ³•ï¼Œä¸ºä¸»ç¨‹åºç”Ÿæˆä¸€ä¸ª `ImageLoader` å¯¹è±¡ï¼Œç„¶åæŠŠ `ImageLoader` å¯¹è±¡è®¾ç½®åˆ°å…¨å±€çš„é“¾æ¥ä¸Šä¸‹æ–‡ä¸­ã€‚
ä¸‹é¢æ˜¯ç›¸å…³æºç çš„ç®€åŒ–åˆ†æ:

```
static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)
{
	// å°è¯•åŠ è½½ä¸»ç¨‹åºçš„ Mach-O
	if ( isCompatibleMachO((const uint8_t*)mh, path) ) {
		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);
		addImage(image);
		return (ImageLoaderMachO*)image;
	}
	
	throw "main executable not a known format";
}
```

`isCompatibleMachO()` ä¸»è¦æ£€æŸ¥ `Mach-O` çš„å¤´éƒ¨çš„ `cputype` ä¸ `cpusubtype` æ¥åˆ¤æ–­ç¨‹åºä¸å½“å‰çš„ç³»ç»Ÿæ˜¯å¦å…¼å®¹ã€‚å¦‚æœå…¼å®¹ï¼ŒåŠ è½½ä¸»ç¨‹åºçš„ `Mach-O`ï¼Œè°ƒç”¨æ–¹æ³•` ImageLoaderMachO::instantiateMainExecutable()`ã€‚åœ¨è·å–åˆ°ä¸»ç¨‹åºçš„ `ImageLoader` å¯¹è±¡ä¹‹åï¼ŒæŠŠå…¶æ·»åŠ åˆ°å…¨å±€ä¸»åˆ—è¡¨ `sAllImages`ï¼Œæœ€åè°ƒç”¨ `addMappedRange()` ç”³è¯·å†…å­˜ï¼Œæ›´æ–°ä¸»ç¨‹åºæ˜ å°„çš„å†…å­˜åŒºã€‚
ä¸‹é¢æ˜¯æ–¹æ³•` ImageLoaderMachO::instantiateMainExecutable()` çš„ç®€åŒ–ä»£ç ï¼š

```
// create image for main executable
ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext& context)
{
	bool compressed;
	unsigned int segCount;
	unsigned int libCount;
	const linkedit_data_command* codeSigCmd;
	const encryption_info_command* encryptCmd;
	sniffLoadCommands(mh, path, false, &compressed, &segCount, &libCount, context, &codeSigCmd, &encryptCmd);
	// instantiate concrete class based on content of load commands
	if ( compressed ) 
		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);
	else
#if SUPPORT_CLASSIC_MACHO
		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);
#else
		throw "missing LC_DYLD_INFO load command";
#endif
}
```

`sniffLoadCommands()` å‡½æ•°ä¸»è¦æ˜¯è·å– `mach_header` ä¸­ `load command` ä¸­çš„å¦‚ä¸‹ä¿¡æ¯ï¼š

- `compressed`ï¼šåˆ¤æ–­ `Mach-O` æ˜¯ `Compressed` è¿˜æ˜¯ `Classic` ç±»å‹ã€‚æ ¹æ® mach-o æ˜¯å¦åŒ…å« `LC_DYLD_INFO`ã€`LC_DYLD_INFO_ONLY` å’Œ `LC_DYLD_CHAINED_FIXUPS` åŠ è½½å‘½ä»¤æ¥åˆ¤æ–­ã€‚å‰ä¸¤ä¸ªå‘½ä»¤è®°å½•äº†`Mach-O` çš„åŠ¨æ€åº“åŠ è½½ä¿¡æ¯ï¼Œæœ€åä¸€ä¸ªå‘½ä»¤è®°å½•äº† `Mach-O` çš„åŠ¨æ€åº“çš„é“¾æ¥ä¿¡æ¯ã€‚å‰ä¸¤ä¸ªå‘½ä»¤ä½¿ç”¨ç»“æ„ä½“`dyld_info_command` è¡¨ç¤ºï¼š

  ```
  struct dyld_info_command {
     uint32_t   cmd;		/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */
     uint32_t   cmdsize;		/* sizeof(struct dyld_info_command) */
     uint32_t   rebase_off;	/* file offset to rebase info  */
     uint32_t   rebase_size;	/* size of rebase info   */
     uint32_t   bind_off;	/* file offset to binding info   */
     uint32_t   bind_size;	/* size of binding info  */
     uint32_t   weak_bind_off;	/* file offset to weak binding info   */
     uint32_t   weak_bind_size;  /* size of weak binding info  */
     uint32_t   lazy_bind_off;	/* file offset to lazy binding info */
     uint32_t   lazy_bind_size;  /* size of lazy binding infs */
     uint32_t   export_off;	/* file offset to lazy binding info */
     uint32_t   export_size;	/* size of lazy binding infs */
  };
  ```

  - `rebase_off` å’Œ `rebase_size` å­˜å‚¨äº†ä¸ `rebase`(é‡è®¾åŸºå‡†)ç›¸å…³ä¿¡æ¯ã€‚å½“ `dyld` å°† `Mach-O` åŠ è½½åˆ°ä¸å…¶é¦–é€‰åœ°å€ä¸åŒçš„å†…å­˜åœ°å€æ—¶ï¼Œ`dyld` ä¼šå¯¹ `Mach-O` é‡æ–°è®¾ç½®åŸºå‡†ã€‚
  -  `bind_off` ä¸ `bind_size` å­˜å‚¨äº†è¿›ç¨‹çš„ç¬¦å·ç»‘å®šä¿¡æ¯ï¼Œå½“è¿›ç¨‹å¯åŠ¨æ—¶å¿…é¡»ç»‘å®šè¿™äº›ç¬¦å·ï¼Œå…¸å‹çš„æœ‰`dyld_stub_binder`ï¼Œè¯¥ç¬¦å·è¢« `dyld` ç”¨æ¥åšè¿Ÿç»‘å®šåŠ è½½ç¬¦å·ï¼Œä¸€èˆ¬åŠ¨æ€åº“éƒ½åŒ…å«è¯¥ç¬¦å·ã€‚
  - `weak_bind_off` ä¸ `weak_bind_size` å­˜å‚¨äº†è¿›ç¨‹çš„å¼±ç»‘å®šç¬¦å·ä¿¡æ¯ã€‚å¼±ç¬¦å·ä¸»è¦ç”¨äºé¢å‘å¯¹æ—¬è¯­è¨€ä¸­çš„ç¬¦å·é‡è½½ï¼Œå…¸å‹çš„æœ‰ `c++` ä¸­ä½¿ç”¨ `new` åˆ›å»ºå¯¹è±¡ï¼Œé»˜è®¤æƒ…å†µä¸‹ä¼šç»‘å®š `ibstdc++.dylib`ï¼Œå¦‚æœæ£€æµ‹åˆ°æŸä¸ªæ˜ åƒä½¿ç”¨å¼±ç¬¦å·å¼•ç”¨é‡è½½äº† `new` ç¬¦å·ï¼Œ`dyld` åˆ™ä¼šé‡æ–°ç»‘å®šè¯¥ç¬¦å·å¹¶è°ƒç”¨é‡è½½çš„ç‰ˆæœ¬ã€‚
  - `lazy_bind_off` ä¸ `lazy_bind_size` å­˜å‚¨äº†è¿›ç¨‹çš„å»¶è¿Ÿç»‘å®šç¬¦å·ä¿¡æ¯ã€‚æœ‰äº›ç¬¦å·åœ¨è¿›ç¨‹å¯åŠ¨æ—¶ä¸éœ€è¦é©¬ä¸Šè§£æï¼Œå®ƒä»¬ä¼šåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶è¢«è§£æï¼Œè¿™ç±»ç¬¦å·å«å»¶è¿Ÿç»‘å®šç¬¦å·ï¼ˆ`Lazy Symbol`ï¼‰ã€‚
  - `export_off` ä¸ `export_size` å­˜å‚¨äº†è¿›ç¨‹çš„å¯¼å‡ºç¬¦å·ç»‘å®šä¿¡æ¯ã€‚å¯¼å‡ºç¬¦å·å¯ä»¥è¢«å¤–éƒ¨çš„ `Mach-O` è®¿é—®ï¼Œé€šå¸¸åŠ¨æ€åº“ä¼šå¯¼å‡ºä¸€ä¸ªæˆ–å¤šä¸ªç¬¦å·ä¾›å¤–éƒ¨ä½¿ç”¨ï¼Œè€Œå¯æ‰§è¡Œç¨‹åºç”±å¯¼å‡º `_main`ä¸ `_mh_execute_header` ç¬¦å·ä¾›`dyld` ä½¿ç”¨ã€‚

  æœ€åä¸€ä¸ªå‘½ä»¤ä½¿ç”¨äº†ç»“æ„ä½“ `linkedit_data_command` è¡¨ç¤ºï¼š

  ```
  struct linkedit_data_command {
      uint32_t	cmd;		/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,
  				   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,
  				   LC_DYLIB_CODE_SIGN_DRS,
  				   LC_LINKER_OPTIMIZATION_HINT,
  				   LC_DYLD_EXPORTS_TRIE, or
  				   LC_DYLD_CHAINED_FIXUPS. */
      uint32_t	cmdsize;	/* sizeof(struct linkedit_data_command) */
      uint32_t	dataoff;	/* file offset of data in __LINKEDIT segment */
      uint32_t	datasize;	/* file size of data in __LINKEDIT segment  */
  };
  ```

  - `dataoff` ä¸ `datasize`  å­˜å‚¨äº† `__LINKEDIT` æ®µç›¸å…³çš„ä¿¡æ¯ï¼Œå±äºé“¾æ¥ä¿¡æ¯ã€‚

  > ä»£ç ç­¾åä¹Ÿä¼šä½¿ç”¨å½“å‰ç»“æ„ä½“

- `segCount`ï¼šæ®µçš„æ•°é‡ã€‚é€šè¿‡éå†æ‰€æœ‰çš„åŠ è½½å‘½ä»¤ `LC_SEGMENT_COMMAND` ç´¯åŠ è·å–æ®µçš„æ•°é‡ã€‚

- `libCount`ï¼šéœ€åŠ è½½çš„åŠ¨æ€åº“çš„æ•°é‡ã€‚é€šè¿‡éå†æ‰€æœ‰çš„ `LC_LOAD_UPWARD_DYLIB`ã€`LC_LOAD_DYLIB`ã€`LC_LOAD_WEAK_DYLIB`ã€`LC_REEXPORT_DYLIB` ç´¯åŠ è·å–åŠ è½½åŠ¨æ€åº“çš„æ•°é‡ã€‚

- `codeSigCmd`ï¼šä»£ç ç­¾åçš„å‘½ä»¤ã€‚é€šè¿‡è§£æ `LC_CODE_SIGNATURE` æ¥è·å–ä»£ç ç­¾åçš„åŠ è½½å‘½ä»¤ã€‚

- `encryptCmd`ï¼šåŠ å¯†å‘½ä»¤ã€‚é€šè¿‡è§£æ `LC_ENCRYPTION_INFO` å’Œ `LC_ENCRYPTION_INFO_64` æ¥è·å–åŠ å¯†çš„åŠ è½½å‘½ä»¤ã€‚

åœ¨è·å–åˆ° `compressed` ä¹‹åï¼Œæ ¹æ®å…¶æ¥åˆ†åˆ«è°ƒç”¨ `ImageLoaderMachOCompressed::instantiateMainExecutable()`ã€`ImageLoaderMachOClassic::instantiateMainExecutable()`ã€‚
è¿™é‡Œä»¥ `ImageLoaderMachOCompressed::instantiateMainExecutable()` ä¸ºä¾‹ï¼Œå…¶æºç å¦‚ä¸‹ï¼š

```
ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, 
																		unsigned int segCount, unsigned int libCount, const LinkContext& context)
{
	ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount);

	// set slide for PIE programs
	image->setSlide(slide);

	// for PIE record end of program, to know where to start loading dylibs
	if ( slide != 0 )
		fgNextPIEDylibAddress = (uintptr_t)image->getEnd();

	image->disableCoverageCheck();
	image->instantiateFinish(context);
	image->setMapped(context);

	if ( context.verboseMapping ) {
		dyld::log("dyld: Main executable mapped %s\n", path);
		for(unsigned int i=0, e=image->segmentCount(); i < e; ++i) {
			const char* name = image->segName(i);
			if ( (strcmp(name, "__PAGEZERO") == 0) || (strcmp(name, "__UNIXSTACK") == 0)  )
				dyld::log("%18s at 0x%08lX->0x%08lX\n", name, image->segPreferredLoadAddress(i), image->segPreferredLoadAddress(i)+image->segSize(i));
			else
				dyld::log("%18s at 0x%08lX->0x%08lX\n", name, image->segActualLoadAddress(i), image->segActualEndAddress(i));
		}
	}

	return image;
}
```

è°ƒç”¨ `ImageLoaderMachOCompressed::instantiateStart(` æ–¹æ³•ï¼Œå…¶ä½¿ç”¨ä¸»ç¨‹åº `Mach-O` çš„ä¿¡æ¯æ„é€ ä¸€ä¸ª `ImageLoaderMachOCompressed` å¯¹è±¡ `image` ã€‚è®¾ç½® `image` å¯¹è±¡çš„ `slide`  å±æ€§ã€‚`image->disableCoverageCheck()` è¡¨ç¤ºç¦ç”¨è¦†ç›–ç‡æ£€æŸ¥ã€‚`image->instantiateFinish(context)` ä¼šè°ƒç”¨ `parseLoadCmds()` æ–¹æ³•æ¥è§£æå…¶ä»–çš„å‘½ä»¤ï¼Œä¼šè®¾ç½®ä¸€äº›ä¿æŠ¤æˆå‘˜ä¿¡æ¯ã€è®¾ç½®åŠ¨æ€åº“é“¾æ¥çš„ä¿¡æ¯ã€è®¾ç½®ç¬¦å·è¡¨çš„ä¿¡æ¯ã€ä¿®å¤é“¾æ¥ç­‰ã€‚æœ€åè®¾ç½® `image` å¯¹è±¡çš„æ˜ å°„ã€‚

##### 3.6 æ£€æŸ¥åº“çš„ç‰ˆæœ¬æ˜¯å¦æœ‰æ›´æ–°ï¼Œæœ‰åˆ™è¦†ç›–åŸæœ‰çš„

è¯¥å‡½æ•°ä¸»è¦æ˜¯è¯»å– `DYLD_VERSIONED_LIBRARY_PATH` å’Œ `DYLD_VERSIONED_FRAMEWORK_PATH` ç¯å¢ƒå˜é‡ï¼Œå°†æŒ‡å®šç‰ˆæœ¬çš„åº“ä¸å½“å‰åŠ è½½çš„åº“çš„ç‰ˆæœ¬åšæ¯”è¾ƒï¼Œå¦‚æœå½“å‰çš„åº“ç‰ˆæœ¬æ›´æ”¹çš„è¯ï¼Œå°±ä½¿ç”¨æ–°ç‰ˆæœ¬çš„åº“æ›¿æ¢æ‰æ—§ç‰ˆæœ¬çš„ã€‚

##### 3.7 åŠ è½½ä»»ä½•æ’å…¥çš„åŠ¨æ€åº“

è¿™ä¸€æ­¥ä¸»è¦æ˜¯å¾ªç¯éå†ç¯å¢ƒå˜é‡ `DYLD_INSERT_LIBRARIES` ä¸­æŒ‡å®šçš„åŠ¨æ€åº“åˆ—è¡¨ï¼Œå¹¶è°ƒç”¨ `loadInsertedDylib()` å°†å…¶åŠ è½½ã€‚`loadInsertedDylib()` è°ƒç”¨ `load()` å‡½æ•°å®ŒæˆåŠ è½½ã€‚`load()` ä¼šè°ƒç”¨ `loadPhase0()` å°è¯•ä»æ–‡ä»¶ä¸­åŠ è½½ï¼Œ`loadPhase0()` ä¼šå‘ä¸‹è°ƒç”¨ä¸‹ä¸€å±‚çš„ `phase` æ¥æŸ¥æ‰¾åŠ¨æ€åº“çš„è·¯å¾„ï¼ŒçŸ¥é“ `loadPhase6()`ï¼ŒæŸ¥æ‰¾çš„é¡ºåº `DYLD_ROOT_PATH` --> `LD_LIBRARY_PATH` --> `DYLD_FRAMEWORK_PATH` -->  `æ–‡ä»¶è‡ªèº«` --> `DYLD_FALLBACK_LIBRARY_PATH`ï¼Œæ‰¾åˆ°æœ€åè°ƒç”¨ `ImageLoaderMachO::instantiateFromFile()` æ¥å®ä¾‹åŒ–ä¸€ä¸ª `ImageLoader`ï¼Œå¹¶è°ƒç”¨ `addImage` åŠ è½½åˆ° `sAllImages`ï¼Œä¹‹åè°ƒç”¨ `checkandAddImage()` éªŒè¯æ˜ åƒå¹¶å°†å…¶åŠ å…¥åˆ°å…¨å±€æ˜ åƒåˆ—è¡¨ä¸­ã€‚å¦‚æœ `loadPhase0()` è¿”å›ä¸ºç©ºï¼Œè¡¨ç¤ºåœ¨è·¯å¾„ä¸‹æ²¡æœ‰æ‰¾åˆ°åŠ¨æ€åº“ï¼Œå°±å°è¯•ä»å…±äº«ç¼“å­˜ä¸­æ‰¾ï¼Œæ‰¾åˆ°ä¹‹åè°ƒç”¨ `ImageLoaderMachO::instantiateFromCache()` ä»ç¼“å­˜ä¸­åŠ è½½ï¼Œå¦åˆ™å°±æŠ›å‡ºæ²¡æ‰¾åˆ°æ˜ åƒçš„å¼‚å¸¸ã€‚ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
ImageLoader* load(const char* path, const LoadContext& context, unsigned& cacheIndex)
{
	...
	ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, NULL);
	if ( image != NULL ) {
		CRSetCrashLogMessage2(NULL);
		return image;
	}
	...
	if ( image == NULL)
		image = loadPhase2cache(path, orgPath, context, cacheIndex, &exceptions);

    CRSetCrashLogMessage2(NULL);
	...
}
```

##### 3.8 é“¾æ¥ä¸»ç¨‹åº

è¿™ä¸€æ­¥ä¸»è¦æ˜¯æ‰§è¡Œ `link()` å‡½æ•°å®Œæˆä¸»ç¨‹åºçš„é“¾æ¥æ“ä½œã€‚é€šè¿‡è°ƒç”¨ `ImageLoader` è‡ªèº«çš„ `link()` å‡½æ•°ï¼Œä¸»è¦æ˜¯å°†å·²ç»å®ä¾‹åŒ–çš„ä¸»ç¨‹åºçš„åŠ¨æ€æ•°æ®è¿›è¡Œä¿®æ­£ï¼Œè¾¾åˆ°è®©è¿›ç¨‹å¯ç”¨çš„ç›®çš„ï¼Œå…¶ä¸­å°±åŒ…æ‹¬ä¸»ç¨‹åºçš„ç¬¦å·è¡¨ä¿®æ­£æ“ä½œã€‚æºç ç®€åŒ–å¦‚ä¸‹ï¼š

```
void ImageLoader::link(const LinkContext& context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain& loaderRPaths, const char* imagePath)
{
	...
	/// é‡‡ç”¨é€’å½’çš„æ–¹å¼æ¥åŠ è½½ç¨‹åºä¾èµ–çš„åŠ¨æ€åº“
	this->recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);

	context.clearAllDepths();
	/// é€’å½’å¯¹image åŠä¾èµ–åº“æŒ‰åˆ—è¡¨è¿›è¡Œæ’åº
	this->recursiveUpdateDepth(context.imageCount());
	...
	/// é€’å½’rebaseæ“ä½œ
	this->recursiveRebaseWithAccounting(context);

	if ( !context.linkingMainExecutable )
		/// é€’å½’ç»‘å®šç¬¦å·è¡¨æ“ä½œ
		this->recursiveBindWithAccounting(context, forceLazysBound, neverUnload);

	/// ç°åœ¨ä¸»è¦æ˜¯é“¾æ¥ç¨‹åºï¼Œæ‰€ä»¥ä¸‹åˆ— !context.linkingMainExecutable éƒ½ä¸ä¼šæ‰§è¡Œ
	if ( !context.linkingMainExecutable )
		/// å¼±ç¬¦å·ç»‘å®š
		this->weakBind(context);
	}

	// interpose any dynamically loaded images
	if ( !context.linkingMainExecutable && (fgInterposingTuples.size() != 0) ) {
		dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);
		this->recursiveApplyInterposing(context);
	}

	// now that all fixups are done, make __DATA_CONST segments read-only
	if ( !context.linkingMainExecutable )
		this->recursiveMakeDataReadOnly(context);

    if ( !context.linkingMainExecutable )
        context.notifyBatch(dyld_image_state_bound, false);
	uint64_t t6 = mach_absolute_time();

	if ( context.registerDOFs != NULL ) {
		std::vector<DOFInfo> dofs;
		/// æ³¨å†Œç¨‹åºçš„DOFèŠ‚åŒº
		this->recursiveGetDOFSections(context, dofs);
		context.registerDOFs(dofs);
	}
	...
}
```

è°ƒç”¨ `recursiveLoadLibraries()`ï¼Œé‡‡ç”¨é€’å½’çš„æ–¹å¼æ¥åŠ è½½ç¨‹åºæ‰€ä¾èµ–çš„åŠ¨æ€åº“ï¼Œåè€…è°ƒç”¨äº† `doGetDependentLibraries()` å‡½æ•°ï¼Œä» `LC_LOAD_DYLIB`ã€`LC_LOAD_WEAK_DYLIB`ã€`LC_REEXPORT_DYLIB`ã€`LC_LOAD_UPWARD_DYLIB` ä¸­è·å–æ‰€æœ‰ä¾èµ–çš„åº“ã€‚æ¥ç€ï¼Œå¾ªç¯æ‰€ä¾èµ–çš„åº“ï¼Œè°ƒç”¨ `context.loadLibrary()` åŠ è½½ã€‚ä»ä¹‹å‰çš„**è®¾ç½®ä¸Šä¸‹æ–‡**(`gLinkContext.loadLibrary= &libraryLocator`)ä¸­å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œå…¶å®è°ƒç”¨çš„æ˜¯ `libraryLocator`ï¼Œè€Œä¸”è¿˜æ˜¯é€šè¿‡ `load` æ¥åŠ è½½ã€‚åŠ è½½æ‰€æœ‰çš„ä¾èµ–åº“ä¹‹åï¼Œä¼šé€’å½’çš„å¯¹ä¾èµ–åº“è¿›è¡Œæ’åºï¼Œè¢«ä¾èµ–çš„åº“æ’åœ¨åˆ—è¡¨å‰é¢ã€‚ç„¶åè°ƒç”¨ `recursiveRebaseWithAccounting()` å‡½æ•°è¿›è¡Œ `rebase` æ“ä½œï¼Œå…¶å†…éƒ¨è°ƒç”¨ `recursiveRebase()`ï¼Œ`recursiveRebase()` å†…éƒ¨è°ƒç”¨ `doRebase()`ï¼Œ`doRebase()` å†…éƒ¨è°ƒç”¨ `ImageLoaderMachO` çš„ `rebase()` å‡½æ•°ä» `fDyldInfo->rebase_off` å¼€å§‹çš„ `rebase_size` è¿›è¡Œ `rebase` æ“ä½œã€‚å¯ä»¥è®¾ç½® `DYLD_PRINT_REBASINGS` å‚æ•°æ¥æŸ¥çœ‹ç›¸å…³æ—¥å¿—è¾“å‡ºï¼Œå› ä¸ºæ¨¡å—è¢«åŠ è½½çš„å†…å­˜åŸºåœ°å€ä¸åŒï¼Œæ‰€ä»¥éœ€è¦ `rebase`ã€‚è®¾ç½®æˆªå›¾å¦‚ä¸‹ï¼š
![image-20200607215049158](<http://blog.objccf.com/blog/2020-06-07-135046.png>)

æ‰“å°å¦‚ä¸‹ï¼š
![image-20200607215338483](http://blog.objccf.com/blog/2020-06-07-135336.png)

`recursiveBindWithAccounting()` ä¼šè°ƒç”¨ `recursiveBind()`ï¼Œå†…éƒ¨ä¼šä»¥é€’å½’çš„æ–¹å¼ç»‘å®šç¬¦å·è¡¨ï¼Œæ­£å¸¸æƒ…å†µä¸‹åªç»‘å®šéæ‡’åŠ è½½ç¬¦å·ï¼Œé™¤éæ»¡è¶³ä¸€ä¸‹æ¡ä»¶ï¼š

- è®¾ç½® `DYLD_BIND_AT_LAUNCH`ï¼Œæ‡’åŠ è½½ç¬¦å·ä¼šç«‹å³ç»‘å®š
- ä½¿ç”¨æŸäº›APIï¼Œä¾‹å¦‚ `RTLD_NOW`ï¼Œä¼šå¯¼è‡´æ‡’åŠ è½½ç¬¦å·ç«‹å³ç»‘å®š

ä¸‹é¢æ˜¯ç»‘å®šçš„å…¶ä½™ç®€åŒ–æºç ï¼š

```
void ImageLoader::recursiveBind(const LinkContext& context, bool forceLazysBound, bool neverUnload)
{
	// Normally just non-lazy pointers are bound immediately.
	// The exceptions are:
	//   1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately
	//   2) some API's (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately
	if ( fState < dyld_image_state_bound ) {
		// break cycles
		fState = dyld_image_state_bound;
	
		try {
			// bind lower level libraries first
			for(unsigned int i=0; i < libraryCount(); ++i) {
				ImageLoader* dependentImage = libImage(i);
				if ( dependentImage != NULL )
					dependentImage->recursiveBind(context, forceLazysBound, neverUnload);
			}
			// bind this image
			this->doBind(context, forceLazysBound);	
			...
		}
		catch (const char* msg) {
			...
		}
	}
}
void ImageLoaderMachOCompressed::doBind(const LinkContext& context, bool forceLazysBound)
{
	...
	if ( this->usablePrebinding(context) ) {
		// don't need to bind
		// except weak which may now be inline with the regular binds
		if (this->participatesInCoalescing()) {
			// run through all binding opcodes
			eachBind(context, ^(const LinkContext& ctx, ImageLoaderMachOCompressed* image,
								uintptr_t addr, uint8_t type, const char* symbolName,
								uint8_t symbolFlags, intptr_t addend, long libraryOrdinal,
								ExtraBindData *extraBindData,
								const char* msg, LastLookup* last, bool runResolver) {
				if ( libraryOrdinal != BIND_SPECIAL_DYLIB_WEAK_LOOKUP )
					return (uintptr_t)0;
				return ImageLoaderMachOCompressed::bindAt(ctx, image, addr, type, symbolName, symbolFlags,
														  addend, libraryOrdinal, extraBindData,
														  msg, last, runResolver);
			});
		}
	}
	else {
		...
		if ( fChainedFixups != NULL ) {
			...
		}
		else {
			// run through all binding opcodes
			eachBind(context, ^(const LinkContext& ctx, ImageLoaderMachOCompressed* image,
								uintptr_t addr, uint8_t type, const char* symbolName,
								uint8_t symbolFlags, intptr_t addend, long libraryOrdinal,
								ExtraBindData *extraBindData,
								const char* msg, LastLookup* last, bool runResolver) {
				return ImageLoaderMachOCompressed::bindAt(ctx, image, addr, type, symbolName, symbolFlags,
														  addend, libraryOrdinal, extraBindData,
														  msg, last, runResolver);
			});
			...
	}
	..
}
uintptr_t ImageLoaderMachOCompressed::bindAt{
	...
	return image->bindLocation(context, image->imageBaseAddress(), addr, symbolAddress,
    	type, symbolName, addend, image->getPath(), targetImage ? targetImage->getPath() : 
    	NULL, msg, extraBindData, image->fSlide);
}
```

`eachBind` é€šè¿‡è°ƒç”¨ `fDyldInfo->bind_off` å¼€å§‹çš„ `bind_size` è·å–ä½ç½®å’Œç¬¦å·åï¼Œæœ€ååœ¨è°ƒç”¨ `ImageLoaderMachOCompressed::bindAt()` è¿›è¡Œç»‘å®šã€‚åœ¨ `ImageLoaderMachOCompressed::bindAt()` è°ƒç”¨ `image->resolve()` è·å–ç¬¦å·åœ°å€ï¼Œåœ¨è°ƒç”¨ `image->bindLocation()` æ¥æ›´æ–°ç»‘å®šã€‚éœ€è¦ç»‘å®šçš„ç¬¦å·ä¿¡æ¯æœ‰ä¸‹é¢å‡ ç§ï¼š

- `BIND_TYPE_POINTER`ï¼šéœ€è¦ç»‘å®šçš„æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚ç›´æ¥å°†è®¡ç®—å¥½çš„æ–°å€¼å±¿å€¼å³å¯ã€‚
- `BIND_TYPE_TEXT_ABSOLUTE32`ï¼šä¸€ä¸ª32ä½çš„å€¼ã€‚å–è®¡ç®—çš„å€¼çš„ä½32ä½èµ‹å€¼è¿‡å»ã€‚
- `BIND_TYPE_TEXT_PCREL32`ï¼šé‡å®šä½ç¬¦å·ã€‚éœ€è¦ä½¿ç”¨æ–°å€¼å‡æ‰éœ€è¦ä¿®æ­£çš„åœ°å€å€¼æ¥è®¡ç®—å‡ºé‡å®š

å¯ä»¥é€šè¿‡è®¾ç½® `DYLD_PRINT_BINDINGS` æ¥æ‰“å°ç»‘å®šä¿¡æ¯ï¼Œæˆªå›¾å¦‚ä¸‹ï¼š

![image-20200607231936856](http://blog.objccf.com/blog/2020-06-07-151932.png)

è¿è¡Œä¹‹åçš„æ‰“å°ä¿¡æ¯å¦‚ä¸‹ï¼š
![image-20200607232107319](http://blog.objccf.com/blog/2020-06-07-152111.png)

`recursiveGetDOFSections()` å†…éƒ¨é€šè¿‡é€’å½’çš„æ–¹å¼å»å¤„ç†DOFä¿¡æ¯ã€‚æœ€åé€šè¿‡ `registerDOFs() `æ³¨å†Œç¨‹åºçš„ `DOF `èŠ‚åŒºï¼Œä¾› `dtrace` ä½¿ç”¨ã€‚

##### 3.9 é“¾æ¥æ‰€æœ‰æ’å…¥çš„åº“

æ­¤æ­¥éª¤ä¸ä¸é“¾æ¥ä¸»ç¨‹åºä¸€æ ·ï¼Œéƒ½æ˜¯è°ƒç”¨ `link()` è¿›è¡Œé“¾æ¥ï¼Œè¿™é‡Œæ˜¯å¯¹ `sAllImages` (é™¤äº†ä¸»ç¨‹åº)ä¸­çš„åº“è¿›è¡Œé“¾æ¥ï¼Œ`sAllImages` åˆ—è¡¨æ¥è‡ªå‰é¢æ’å…¥çš„åŠ¨æ€åº“ã€‚åœ¨é“¾æ¥ä¹‹åï¼Œä¼šè°ƒç”¨ `registerInterposing()` æ³¨å†Œç¬¦å·æ›¿æ¢ï¼Œè¯¥å‡½æ•°è¯»å–`__DATA`ï¼Œ`__INTERPOSE` æ®µçš„å‡½æ•°å’Œæ›¿æ¢çš„å‡½æ•°ï¼Œå¹¶å°†è¯»å–çš„ä¿¡æ¯ä¿å­˜åˆ° `ImageLoader::fgInterposingTuples` ä¸­ï¼Œä¸ºæ¥ä¸‹æ¥çš„æ›¿æ¢ç¬¦å·åšå‡†å¤‡ã€‚æ¥ä¸‹æ¥ä¼šè°ƒç”¨ `ImageLoader::applyInterposing()` å‡½æ•°ï¼Œå…¶å†…éƒ¨è°ƒç”¨ `recursiveApplyInterposing()` å‡½æ•°ï¼Œåœ¨`recursiveApplyInterposing()` å‡½æ•°é€’å½’è°ƒç”¨ï¼Œæœ€ç»ˆéœ€è¦è°ƒç”¨ `doInterpose()` è¿›è¡Œç¬¦å·æ›¿æ¢ã€‚`doInterpose()` å®é™…è°ƒç”¨äº† `eachBind()` å’Œ `eachLazyBind()` å‡½æ•°ï¼Œåˆ†åˆ«å¯¹å¸¸è§„çš„ç¬¦å·ä¸å»¶è¿ŸåŠ è½½çš„ç¬¦å·è¿›è¡Œåº”ç”¨æ’å…¥æ“ä½œï¼Œä¹‹åä¼šè°ƒç”¨ `interposeAt()` è¿›è¡Œæœ€ç»ˆæ›¿æ¢ã€‚åœ¨ `interposeAt()` ä¸­ä¼šè°ƒç”¨ `interposedAddress()` åœ¨ `fgInterposingTuples` ä¸­æŸ¥æ‰¾è¦æ›¿æ¢çš„ç¬¦å·åœ°å€ï¼Œæ‰¾åˆ°åç„¶åè¿›è¡Œæœ€ç»ˆçš„ç¬¦å·åœ°å€æ›¿æ¢ã€‚
å¯ä»¥é€šè¿‡è®¾ç½® `DYLD_PRINT_INTERPOSING` æ¥æ‰“å°æ›¿æ¢çš„æ—¥å¿—ã€‚å…·ä½“æ–¹å¼è§ä¹‹å‰çš„è®¾ç½®æ‰“å°ã€‚
éƒ¨åˆ†ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```

for(unsigned int i=0; i < sInsertedDylibCount; ++i) {
	ImageLoader* image = sAllImages[i+1];
	link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);
	image->setNeverUnloadRecursive();
}
for(unsigned int i=0; i < sInsertedDylibCount; ++i) {
    ImageLoader* image = sAllImages[i+1];
    image->registerInterposing(gLinkContext);
}
...
// apply interposing to initial set of images
for(int i=0; i < sImageRoots.size(); ++i) {
    sImageRoots[i]->applyInterposing(gLinkContext);
}

ImageLoader::applyInterposingToDyldCache(gLinkContext);
////////////
void ImageLoaderMachO::registerInterposing(const LinkContext& context)
{
	// mach-o files advertise interposing by having a __DATA __interpose section
	...
	for (uint32_t i = 0; i < cmd_count; ++i) {
		switch (cmd->cmd) {
			case LC_SEGMENT_COMMAND:
						...
						if ( ((sect->flags & SECTION_TYPE) == S_INTERPOSING) || ((strcmp(sect->sectname, "__interpose") == 0) && (strcmp(seg->segname, "__DATA") == 0)) ) {
							...
									ImageLoader::fgInterposingTuples.push_back(tuple);
								}
							}
						}
					}
				}
				break;
		}
		cmd = (const struct load_command*)(((char*)cmd)+cmd->cmdsize);
	}
}

void ImageLoader::applyInterposing(const LinkContext& context)
{
	dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);
	if ( fgInterposingTuples.size() != 0 )
		this->recursiveApplyInterposing(context);
}

void ImageLoader::recursiveApplyInterposing(const LinkContext& context)
{
	// interpose lower level libraries first
	for(unsigned int i=0; i < libraryCount(); ++i) {
		ImageLoader* dependentImage = libImage(i);
		if ( dependentImage != NULL )
			dependentImage->recursiveApplyInterposing(context);
	}
		
	// interpose this image
	doInterpose(context);
}

void ImageLoaderMachOCompressed::doInterpose(const LinkContext& context)
{
	if ( !ma->hasChainedFixups() ) {
		eachLazyBind(xxx) {
			return ImageLoaderMachOCompressed::interposeAt(xxx);
		});

	  	// 2) non-lazy pointers in the dyld cache need to be interposed
		if ( ma->inDyldCache() ) {
			eachBind(xxx) {
				return ImageLoaderMachOCompressed::interposeAt(...);
			});
		}
	}
}
uintptr_t ImageLoaderMachOCompressed::interposeAt(...)
{
	if ( type == BIND_TYPE_POINTER ) {
		uintptr_t* fixupLocation = (uintptr_t*)addr;
		uintptr_t curValue = *fixupLocation;
		uintptr_t newValue = interposedAddress(context, curValue, image);
		if ( newValue != curValue) {
			*fixupLocation = newValue;
		}
	}
	return 0;
}
```

##### 3.10 æ‰§è¡Œå¼±ç¬¦å·ç»‘å®š: ä»…åœ¨é“¾æ¥æ‰€æœ‰æ’å…¥çš„imagesåæ‰æ‰§è¡Œå¼±ç¬¦å·ç»‘å®š

åˆ°è¿™é‡Œæ‰€æœ‰æ’å…¥çš„åŠ¨æ€åº“éƒ½å·²ç»æ‰§è¡Œäº†æ’å…¥æ“ä½œ
å¼±ç»‘å®šé¦–å…ˆè·å–å‚ä¸ç»‘å®šçš„ `ImageLoader`ï¼Œè°ƒç”¨æ–¹æ³• `getCoalescedImages()`ï¼Œè¯¥æ–¹æ³•ä¼šå°†æ‰€æœ‰å«æœ‰å¼±ç¬¦å·çš„æ˜ å°„ç»„æˆä¸€ä¸ªåˆ—è¡¨ï¼Œç„¶åå¾ªç¯è®¡ç®—å‡ºæœ‰å¤šå°‘ä½å®Œæˆå¼±ç»‘å®š `ImageLoader`ï¼Œè®¡ç®—å®Œæˆä¹‹åï¼Œè°ƒç”¨æ–¹æ³• `initializeCoalIterator()` å¯¹éœ€è¦ç»‘å®šçš„å¼±ç¬¦å·æ•°æ®è¿›è¡Œæ’åºã€‚æ’åºåè°ƒç”¨ `incrementCoalIterator()` è¯»å– `image` åŠ¨æ€ç»‘å®šä¿¡æ¯çš„åç§»å’Œå¤§å°ï¼Œä¸»è¦æ˜¯é€šè¿‡è¯»å– `weak_bind_off` ä¸ `weak_bind_size` æ¥ç¡®å®šå¼±ç¬¦å·çš„æ•°æ®åç§»ä¸å¤§å°ï¼Œé€šè¿‡è®¡ç®—è·å–åˆ°åœ°å€ä¿¡æ¯ã€‚ä¹‹åä¼šé‡æ–°è¿›è¡Œæ’åºï¼Œæ’åºåè°ƒç”¨ `getAddressCoalIterator()` æŸ¥æ‰¾ç¬¦å·çš„åœ°å€ï¼Œæ‰¾åˆ°åœ°å€åè°ƒç”¨ `updateUsesCoalIterator()` æ‰§è¡Œç»‘å®šæ“ä½œã€‚`updateUsesCoalIterator` ä¼šè°ƒç”¨ `bindLocation()`ï¼Œè¯¥å‡½æ•°ä¸Šæ–‡æœ‰æè¿°è¿‡ï¼Œè¿™é‡Œä¸å†æè¿°ã€‚
ä¸‹é¢æ˜¯ç®€åŒ–çš„æºç ï¼š

```
void ImageLoader::weakBind(const LinkContext& context)
{
	...
	// è·å¾—å‚ä¸åˆå¹¶çš„ ImageLoader
	ImageLoader* imagesNeedingCoalescing[fgImagesRequiringCoalescing];
	unsigned imageIndexes[fgImagesRequiringCoalescing];
	int count = context.getCoalescedImages(imagesNeedingCoalescing, imageIndexes);
	
	// è®¡ç®—æœ‰å¤šå°‘ImageLoaderå°šæœªå®Œæˆå¼±ç»‘å®š
	int countNotYetWeakBound = 0;
	int countOfImagesWithWeakDefinitionsNotInSharedCache = 0;
	for(int i=0; i < count; ++i) {
		if ( ! imagesNeedingCoalescing[i]->weakSymbolsBound(imageIndexes[i]) )
			++countNotYetWeakBound;
		if ( ! imagesNeedingCoalescing[i]->inSharedCache() )
			++countOfImagesWithWeakDefinitionsNotInSharedCache;
	}

	if ( (countOfImagesWithWeakDefinitionsNotInSharedCache > 0) && (countNotYetWeakBound > 0) ) {
		if (!context.weakDefMapInitialized) {
			// åˆå§‹åŒ–å¼±å®šä¹‰æ˜ å°„ï¼Œå› ä¸ºé“¾æ¥ä¸Šä¸‹æ–‡æœªè¿è¡Œé™æ€åˆå§‹åŒ–ç¨‹åº
			new (&context.weakDefMap) dyld3::Map<const char*, std::pair<const ImageLoader*, uintptr_t>, ImageLoader::HashCString, ImageLoader::EqualCString>();
			context.weakDefMapInitialized = true;
		}
		ImageLoader::CoalIterator iterators[count];
		ImageLoader::CoalIterator* sortedIts[count];
		/// å¯¹éœ€è¦ç»‘å®šçš„å¼±ç¬¦å·è¿›è¡Œæ’åº
		for(int i=0; i < count; ++i) {
			imagesNeedingCoalescing[i]->initializeCoalIterator(iterators[i], i, imageIndexes[i]);
			sortedIts[i] = &iterators[i];
		}
		int doneCount = 0;
		while ( doneCount != count ) {
		
			// è¯»å–æ˜ åƒåŠ¨æ€é“¾æ¥ä¿¡æ¯çš„weak_bind_offä¸weak_bind_sizeæ¥ç¡®å®šå¼±ç¬¦å·çš„æ•°æ®åç§»ä¸å¤§å°
			if ( sortedIts[0]->image->incrementCoalIterator(*sortedIts[0]) )
				++doneCount; 
			// é‡æ–°æ’åº
			for(int i=1; i < count; ++i) {
				int result = strcmp(sortedIts[i-1]->symbolName, sortedIts[i]->symbolName);
				if ( result == 0 )
					sortedIts[i-1]->symbolMatches = true;
				if ( result > 0 ) {
					// new one is bigger then next, so swap
					ImageLoader::CoalIterator* temp = sortedIts[i-1];
					sortedIts[i-1] = sortedIts[i];
					sortedIts[i] = temp;
				}
				if ( result < 0 )
					break;
			}
			if ( sortedIts[0]->symbolMatches && !sortedIts[0]->done ) {
				....
				for(int i=0; i < count; ++i) {
					if ( strcmp(iterators[i].symbolName, nameToCoalesce) == 0 ) {
						if ( iterators[i].weakSymbol ) {
							if ( targetAddr == 0 ) {
								/// æŒ‰ç…§æ˜ åƒçš„åŠ è½½é¡ºåºåœ¨å¯¼å‡ºè¡¨ä¸­æŸ¥æ‰¾ç¬¦å·çš„åœ°å€
								targetAddr = iterators[i].image->getAddressCoalIterator(iterators[i], context);
							}
						}
						else {
							/// æŒ‰ç…§æ˜ åƒçš„åŠ è½½é¡ºåºåœ¨å¯¼å‡ºè¡¨ä¸­æŸ¥æ‰¾ç¬¦å·çš„åœ°å€
							targetAddr = iterators[i].image->getAddressCoalIterator(iterators[i], context);
						}
					}
				}
				if ( targetAddr != 0 ) {
					for(int i=0; i < count; ++i) {
						if ( strcmp(iterators[i].symbolName, nameToCoalesce) == 0 ) {
							if ( ! iterators[i].image->weakSymbolsBound(imageIndexes[i]) )
								
								iterators[i].image->updateUsesCoalIterator(...);
						}
					}
				}
			}
		}

		...
}
```

##### 3.11 åˆå§‹åŒ–ä¸»ç¨‹åº

å½“å‰æ­¥éª¤ä¸»è¦æ˜¯è°ƒç”¨ `initializeMainExecutable()`  å‡½æ•°å®Œæˆã€‚ä¼šå…ˆåˆå§‹åŒ–æ‰€æœ‰æ’å…¥çš„ `dylib`ï¼Œç„¶ååœ¨åˆå§‹åŒ–ä¸»ç¨‹åºã€‚`initializeMainExecutable()`  å‡½æ•°å…ˆè°ƒç”¨ `runInitializers()`ï¼Œå†…éƒ¨åœ¨ä¾æ¬¡è°ƒç”¨`processInitializers()`ã€`recursiveInitialization()`ã€‚ä¸‹é¢æ˜¯ `recursiveInitialization()` çš„ç®€åŒ–æºç ï¼š

```
void ImageLoader::recursiveInitialization(...)
{
	context.notifySingle(dyld_image_state_dependents_initialized, this, &timingInfo);
	
	// initialize this image
	bool hasInitializers = this->doInitialization(context);
	// let anyone know we finished initializing this image
	context.notifySingle(dyld_image_state_initialized, this, NULL);
}
```

é¦–å…ˆè°ƒç”¨ `notifySingle()` å»é€šçŸ¥ `objc`ï¼Œè¿™é‡Œå³å°†åˆå§‹åŒ– `image`ï¼Œç„¶åé€šè¿‡è°ƒç”¨ `doInitialization()` è¿›è¡Œ`image` çš„åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ä¹‹ååœ¨è°ƒç”¨ `notifySingle()` é€šçŸ¥ `objc`ï¼Œå·²ç»åˆå§‹åŒ–å®Œæˆã€‚
`notifySingle` çš„ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
static void notifySingle(...)
{
	...
	if ( (state == dyld_image_state_dependents_initialized) && (sNotifyObjCInit != NULL) && image->notifyObjC() ) {
		uint64_t t0 = mach_absolute_time();
		dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image->machHeader(), 0, 0);
		(*sNotifyObjCInit)(image->getRealPath(), image->machHeader());
		..
	}
	...
}
```

è¿™é‡Œé‡ç‚¹å…³æ³¨ä¸‹ `sNotifyObjCInit`, `objc` åˆå§‹åŒ–çš„é€šçŸ¥ã€‚å…¶å®šä¹‰å¦‚ä¸‹ï¼š

```
static _dyld_objc_notify_init		sNotifyObjCInit;
```

ä¸‹é¢æ¥æœç´¢ä¸‹ `sNotifyObjCInit` çš„èµ‹å€¼ä½ç½®ï¼Œå…¶ä»£ç å¦‚ä¸‹ï¼š

```
void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)
{
	sNotifyObjCMapped	= mapped;
	sNotifyObjCInit		= init;
	sNotifyObjCUnmapped = unmapped;
	...
}
```

å…¨å±€æœç´¢ `registerObjCNotifiers` è°ƒç”¨ï¼Œå…¶ä»£ç å¦‚ä¸‹ï¼š

```
void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,
                                _dyld_objc_notify_init      init,
                                _dyld_objc_notify_unmapped  unmapped)
{
	dyld::registerObjCNotifiers(mapped, init, unmapped);
}

```

å…¨å±€æœç´¢ `_dyld_objc_notify_register` è°ƒç”¨ï¼Œå…¶ä»£ç å¦‚ä¸‹ï¼š

```
// 
// Note: only for use by objc runtime
// Register handlers to be called when objc images are mapped, unmapped, and initialized.
// Dyld will call back the "mapped" function with an array of images that contain an objc-image-info section.
// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to
// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),
// dyld will call the "mapped" function with already loaded objc images.  During any later dlopen() call,
// dyld will also call the "mapped" function.  Dyld will call the "init" function when dyld would be called
// initializers in that image.  This is when objc calls any +load methods in that image.
//
void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,
                                _dyld_objc_notify_init      init,
                                _dyld_objc_notify_unmapped  unmapped);
```

å¤§ä½“æ„æ€: æ­¤å‡½æ•°ä»…ä¾› `objc runtime` ä½¿ç”¨ï¼Œå½“æ˜ å°„ã€å–æ¶ˆæ˜ å°„å’Œåˆå§‹åŒ– `objc` çš„æ—¶å€™å°†è°ƒç”¨è¯¥å‡½æ•°æ¥æ³¨å†Œå¤„ç†ç¨‹åºã€‚`dyld` å°†ä½¿ç”¨åŒ…å« `objc-image-info` ç›¸å…³çš„ `images`  å»è°ƒç”¨ **æ˜ å°„** å‡½æ•°ã€‚åœ¨è°ƒç”¨ `_dyld_objc_notify_register()` çš„è¿‡ç¨‹ä¸­ï¼Œ`dyld` å°†ä½¿ç”¨å·²åŠ è½½çš„ `objc image` è°ƒç”¨â€œæ˜ å°„â€å‡½æ•°ã€‚`objc` ä¸­ä»»ä½•è°ƒç”¨ `+load` æ–¹æ³•çš„æ—¶å€™ï¼Œ`dyld` éƒ½ä¼šè°ƒç”¨  **init** å‡½æ•°ã€‚ä¸‹é¢æ¥è¯æ˜ä¸€ä¸‹ï¼Œæ–°å»º iOS ç¨‹åºï¼Œå¦‚ä¸‹ä¸‹æ–­ç‚¹ï¼š

â€‹                                           Â ![image-20200617154200755](http://blog.objccf.com/blog/2020-06-17-074201.png)

â€‹                              ![image-20200617154327385](http://blog.objccf.com/blog/2020-06-17-074327.png)

ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š

```
#import "ViewController.h"

@interface ViewController ()

@end

@implementation ViewController

+(void)load {
    NSLog(@"--------");
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
}


@end
```

è¿è¡Œç¨‹åºï¼ŒæˆåŠŸè¿›å…¥æ–­ç‚¹ï¼Œæˆªå›¾å¦‚ä¸‹ï¼š

![image-20200617163051627](http://blog.objccf.com/blog/2020-06-17-083051.png)

ä»å·¦ä¾§è°ƒç”¨æ ˆå¯ä»¥çœ‹å‡ºè°ƒç”¨çš„ä¾æ¬¡é¡ºåºæ˜¯ï¼š`libSystem_initializer`ã€`libdispatch_init`ã€`_os_object_init`ã€`_objc_init`ã€`_dyld_objc_notify_register`ã€‚ä»è°ƒç”¨æ ˆå¯ä»¥çœ‹å‡º `libSystem_initializer` æ˜¯ç”± `doModInitFunctions` è°ƒç”¨çš„ï¼Œå…¶æ˜¯ç”±`doInitialization` è°ƒç”¨çš„ã€‚ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
bool ImageLoaderMachO::doInitialization(const LinkContext& context)
{
	// mach-o has -init and static initializers
	doImageInit(context);
	doModInitFunctions(context);
}
```

`doImageInit` çš„ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
void ImageLoaderMachO::doImageInit(const LinkContext& context)
{
	if ( fHasDashInit ) {
		const uint32_t cmd_count = ((macho_header*)fMachOData)->ncmds;
		const struct load_command* const cmds = (struct load_command*)&fMachOData[sizeof(macho_header)];
		const struct load_command* cmd = cmds;
		for (uint32_t i = 0; i < cmd_count; ++i) {
			switch (cmd->cmd) {
				case LC_ROUTINES_COMMAND:
					Initializer func = (Initializer)(((struct macho_routines_command*)cmd)->init_address + fSlide);
					...
			cmd = (const struct load_command*)(((char*)cmd)+cmd->cmdsize);
		}
	}
}
```

è¯¥å‡½æ•°ä¸»è¦æ˜¯é€šè¿‡è°ƒç”¨ `LC_ROUTINES_COMMAND` çš„å‡½æ•°ï¼Œè¿›è¡Œ `image` çš„åˆå§‹åŒ–ï¼Œé€šè¿‡è®¾ç½®`DYLD_PRINT_INITIALIZERS`ï¼Œå³å¯æ‰“å°å…¶æ—¥å¿—ã€‚
`doModInitFunctions` çš„ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
void ImageLoaderMachO::doModInitFunctions(const LinkContext& context)
{
	if ( fHasInitializers ) {
		...
		for (uint32_t i = 0; i < cmd_count; ++i) {
			if ( cmd->cmd == LC_SEGMENT_COMMAND ) {
				...
				for (const struct macho_section* sect=sectionsStart; sect < sectionsEnd; ++sect) {
					const uint8_t type = sect->flags & SECTION_TYPE;
					if ( type == S_MOD_INIT_FUNC_POINTERS ) {
						Initializer* inits = (Initializer*)(sect->addr + fSlide);
						const size_t count = sect->size / sizeof(uintptr_t);
						...
						for (size_t j=0; j < count; ++j) {
							Initializer func = inits[j];
							...
							bool haveLibSystemHelpersBefore = (dyld::gLibSystemHelpers != NULL);
							{
								dyld3::ScopedTimer(DBG_DYLD_TIMING_STATIC_INITIALIZER, (uint64_t)fMachOData, (uint64_t)func, 0);
								func(context.argc, context.argv, context.envp, context.apple, &context.programVars);
							}
							bool haveLibSystemHelpersAfter = (dyld::gLibSystemHelpers != NULL);
							if ( !haveLibSystemHelpersBefore && haveLibSystemHelpersAfter ) {
								// now safe to use malloc() and other calls in libSystem.dylib
								dyld::gProcessInfo->libSystemInitialized = true;
							}
						}
					}
					else if ( type == S_INIT_FUNC_OFFSETS ) {
						const uint32_t* inits = (uint32_t*)(sect->addr + fSlide);
						...
						for (size_t j=0; j < count; ++j) {
							uint32_t funcOffset = inits[j];
							...
                            Initializer func = (Initializer)((uint8_t*)this->machHeader() + funcOffset);
							bool haveLibSystemHelpersBefore = (dyld::gLibSystemHelpers != NULL);
							{
								dyld3::ScopedTimer(DBG_DYLD_TIMING_STATIC_INITIALIZER, (uint64_t)fMachOData, (uint64_t)func, 0);
                                func(context.argc, context.argv, context.envp, context.apple, &context.programVars);
                            }
							bool haveLibSystemHelpersAfter = (dyld::gLibSystemHelpers != NULL);
							if ( !haveLibSystemHelpersBefore && haveLibSystemHelpersAfter ) {
								dyld::gProcessInfo->libSystemInitialized = true;
							}
						}
					}
				}
			}
			cmd = (const struct load_command*)(((char*)cmd)+cmd->cmdsize);
		}
	}
}
```

è¿™é‡Œä¸»è¦æ˜¯é€šè¿‡ `LC_SEGMENT_COMMAND` å‡½æ•°æ‰¾åˆ° `image` ä¸­ `flags` å­—æ®µä¸º `S_MOD_INIT_FUNC_POINTERS` çš„ `section`ï¼Œç„¶åå»è·å–å‡½æ•°æŒ‡é’ˆå»è°ƒç”¨ `libSystem_initializer` å‡½æ•°ï¼Œå»è¿›è¡Œä¸€äº›åˆ—çš„åˆå§‹åŒ–ã€‚æºç ä¸­ `func(..)` å°±æ˜¯å»è°ƒç”¨ `libSystem_initializer`å‡½æ•°ï¼Œåœ¨éªŒè¯è¿™ä¸ªä¹‹å‰ï¼Œå…ˆåˆ—å‡º `ScopedTimer` çš„ç®€åŒ–æºç ï¼š

```
class VIS_HIDDEN ScopedTimer {
public:
    ScopedTimer(uint32_t code, kt_arg data1, kt_arg data2, kt_arg data3)
        : code(code), data1(data1), data2(data2), data3(data3), data4(0), data5(0), data6(0) {
#if BUILDING_LIBDYLD || BUILDING_DYLD
        startTimer();
#endif
    }

    ~ScopedTimer() {
#if BUILDING_LIBDYLD || BUILDING_DYLD
        endTimer();
#endif
    }
    ..
    void startTimer();
    void endTimer();
    ...
};
```

ç°åœ¨å¼€å§‹éªŒè¯ `func(..)` å°±æ˜¯å»è°ƒç”¨ `libSystem_initializer` å‡½æ•°ã€‚ä¿æŒä¹‹å‰çš„æ–­ç‚¹ï¼Œåœ¨çœŸæœºè¿è¡Œï¼ŒæˆåŠŸå‘½ä¸­`_dyld_objc_notify_register` æ–­ç‚¹ï¼Œå¦‚ä¸‹å›¾ï¼š

![image-20200618135351021](http://blog.objccf.com/blog/2020-06-18-055351.png)

ç‚¹å‡»çº¢è‰²ç®­å¤´æŸ¥çœ‹ `doModInitFunctions` å‡½æ•°ä¸­è°ƒç”¨ `libSystem_initializer` å‡½æ•°çš„ä½ç½®ï¼Œæˆªå›¾å¦‚ä¸‹ï¼š

![image-20200618135521423](http://blog.objccf.com/blog/2020-06-18-055522.png)

> è®°ä½ 0x1029fb2c0 åœ°å€ï¼Œå…¶å®åªè¦è®°ä½å 3 ä½åœ°å€ï¼Œå› ä¸ºASLRï¼ŒåŸºå€ç»å¸¸æ”¹å˜ï¼Œæ‰€ä»¥ä¸‹ä¸€ä¸ªåœ°å€ä¸ä¼šæ˜¯ 0x1029fb2c0ã€‚

ä¸‹é¢ï¼Œç»™ `doModInitFunctions` å‡½æ•°ä¸‹æ–­ç‚¹ï¼Œå¦‚ä¸‹å›¾ï¼š

Â                           ![image-20200618135038133](http://blog.objccf.com/blog/2020-06-18-055038.png)

è¿è¡Œç¨‹åºï¼Œå‘½ä¸­ `doModInitFunctions` å‡½æ•°æ–­ç‚¹ï¼Œæˆªå›¾å¦‚ä¸‹(æ³¨æ„çº¢è‰²ç›‘å¬æŒ‡å‘ï¼Œä¸‹é¢åˆ†æä¼šç”¨åˆ°)ï¼š

![image-20200618135938049](http://blog.objccf.com/blog/2020-06-18-055938.png)

> blr æ˜¯å¸¦è¿”å›çš„è·³è½¬æŒ‡ä»¤ï¼Œè¿™é‡Œçš„æ„æ€æ˜¯è·³è½¬åˆ°x24ä¿å­˜çš„åœ°å€ä¸­å»æ‰§è¡Œã€‚

é€šè¿‡çº¢è‰²ç®­å¤´ã€`doModInitFunctions` å’Œ `ScopedTimer` ç›¸å…³æºç ï¼Œå¯¹æ¯”å¾—çŸ¥ï¼Œ`blr x24`ï¼Œå°±æ˜¯ç›¸å½“äºä¸Šæ–‡çš„`func(..)` è°ƒç”¨ã€‚ä¹Ÿå¯ä»¥é€šè¿‡ `x24` åœ°å€åŠè·³è½¬ä¹‹åçš„å‡½æ•°é¦–åœ°å€æ¥éªŒè¯ã€‚æ‰¾åˆ° `2c0` ç»“å°¾çš„åœ°å€`0x1045f32c0`ï¼Œç„¶åé’ˆå¯¹ `0x1045f32c0` ä¸‹æ–­ç‚¹ï¼Œç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š

```
(lldb) br set -a 0x1045f32c0
Breakpoint 9: where = dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&) + 424, address = 0x00000001045f32c0
(lldb) 
```

å› ä¸ºæ’å…¥çš„åŠ¨æ€åº“å’Œä¸»ç¨‹åºéƒ½ä¼šè°ƒç”¨åˆå§‹åŒ–ï¼Œè¿™é‡Œå…ˆæŠŠ `doModInitFunctions` å‡½æ•°æ–­ç‚¹å–æ¶ˆï¼Œåªå…³æ³¨``0x1045f32c0` æ–­ç‚¹ã€‚
ç»§ç»­è¿è¡Œç¨‹åºï¼Œå‘½ä¸­ `0x1045f32c0` æ–­ç‚¹ï¼Œè¿™é‡Œæ‰“å°ä¸‹ `x24` çš„åœ°å€ï¼Œæ‰“å°å¦‚ä¸‹ï¼š

```
(lldb) x/s $x24
0x1e34247b8: "\xfffffff6W\xffffffbd\xffffffa9\xfffffff4O\x01\xffffffa9\xfffffffd{\x02\xffffffa9\xfffffffd\xffffff83"
(lldb) 
```

`x24` å¯¹åº”åœ°å€æ˜¯ `0x1e34247b8`ï¼Œç„¶ååœ¨ `lldb` ä¸­è¾“å…¥ `si` è¿›å…¥è·³è½¬ä¹‹åçš„è°ƒç”¨ï¼Œæˆªå›¾å¦‚ä¸‹(å…³æ³¨ä¸‹çº¢è‰²ç®­å¤´)ï¼š

![image-20200618141135534](http://blog.objccf.com/blog/2020-06-18-061136.png)

æ ¹æ®çº¢è‰²ç®­å¤´åŠä»¥ä¸Šåˆ†æå¯ä»¥çœ‹å‡ºï¼Œ`func(..)` è°ƒç”¨çš„å°±æ˜¯ `libSystem_initializer` å‡½æ•°ã€‚
`libSystem_initializer` çš„æºç å¦‚ä¸‹ï¼š

```
static __attribute__((constructor)) 
void libSystem_initializer(int argc, const char* argv[], const char* envp[], const char* apple[], const struct ProgramVars* vars)
{
	_libkernel_functions_t libkernel_funcs = {
		.get_reply_port = _mig_get_reply_port,
		.set_reply_port = _mig_set_reply_port,
		.get_errno = __error,
		.set_errno = cthread_set_errno_self,
		.dlsym = dlsym,
	};

	_libkernel_init(libkernel_funcs);

	bootstrap_init();
	mach_init();
	pthread_init();
	__libc_init(vars, libSystem_atfork_prepare, libSystem_atfork_parent, libSystem_atfork_child, apple);
	__keymgr_initializer();
	_dyld_initializer();
	libdispatch_init();
#if !TARGET_OS_EMBEDDED || __IPHONE_OS_VERSION_MAX_ALLOWED >= 50000 // __IPHONE_5_0
	_libxpc_initializer();
#endif
}
```

`libdispatch_init`ã€``_os_object_init` æºç å¦‚ä¸‹ï¼š

```
void
libdispatch_init(void)
{
	...
	_dispatch_hw_config_init();
	_dispatch_vtable_init();
	_os_object_init();
}

void
_os_object_init(void)
{
	return _objc_init();
}
```

`_objc_init` æºç å¦‚ä¸‹ï¼š

```
void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    runtime_init();
    exception_init();
    cache_init();
    _imp_implementationWithBlock_init();

    _dyld_objc_notify_register(&map_images, load_images, unmap_image);

#if __OBJC2__
    didCallDyldNotifyRegister = true;
#endif
}
```

è¯¥å‡½æ•°ä¸»è¦æ˜¯è¿›è¡Œä¸€ç³»åˆ—çš„åˆå§‹åŒ–ï¼Œä¹‹åè°ƒç”¨ `_dyld_objc_notify_register` è¿›è¡Œæ³¨å†Œã€‚ä»ä¸Šé¢çš„`_dyld_objc_notify_register` å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œå…¶å‡½æ•°æ‰€éœ€å‚æ•° `mapped` å’Œ `init`ï¼Œåˆ†åˆ«å¯¹åº” `runtime` ä¸­çš„`map_images` å’Œ `load_images` å‡½æ•°ã€‚`map_images` ä¸»è¦å¤„ç†ç”± `dyld` æ˜ å°„çš„ `image`ï¼Œ`load_images` ä¸»è¦å¤„ç†çš„æ˜¯è°ƒç”¨ `+load` æ–¹æ³•ã€‚
ç°åœ¨è¿‡æ‰ `_dyld_objc_notify_register`æ–­ç‚¹ï¼Œç»§ç»­è¿è¡Œã€‚æˆåŠŸè¿›å…¥ `load` æ–­ç‚¹ï¼Œæˆªå›¾å¦‚ä¸‹ï¼š

![image-20200617172859420](http://blog.objccf.com/blog/2020-06-17-092900.png)

`load_images` ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
void
load_images(const char *path __unused, const struct mach_header *mh)
{
    ...
    // Discover load methods
    prepare_load_methods((const headerType *)mh);
    
    // Call +load methods (without runtimeLock - re-entrant)
    call_load_methods();
}
```

å…ˆé€šè¿‡ `prepare_load_methods` æŸ¥æ‰¾æ‰€æœ‰ç±»çš„ `load` æ–¹æ³•ï¼Œç„¶åè°ƒç”¨ `load` æ–¹æ³•ã€‚
`prepare_load_methods` çš„ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
void prepare_load_methods(const headerType *mhdr)
{
    size_t count, i;

    runtimeLock.assertLocked();

    classref_t const *classlist = 
        _getObjc2NonlazyClassList(mhdr, &count);
    for (i = 0; i < count; i++) {
        schedule_class_load(remapClass(classlist[i]));
    }

    category_t * const *categorylist = _getObjc2NonlazyCategoryList(mhdr, &count);
    for (i = 0; i < count; i++) {
        category_t *cat = categorylist[i];
        Class cls = remapClass(cat->cls);
        if (!cls) continue;  // category for ignored weak-linked class
        realizeClassWithoutSwift(cls, nil);
        ASSERT(cls->ISA()->isRealized());
        add_category_to_loadable_list(cat);
    }
}

static void schedule_class_load(Class cls)
{
    if (!cls) return;
    ASSERT(cls->isRealized());  // _read_images should realize

    if (cls->data()->flags & RW_LOADED) return;

    // Ensure superclass-first ordering
    schedule_class_load(cls->superclass);

    add_class_to_loadable_list(cls);
    cls->setInfo(RW_LOADED); 
}
```

å…ˆéå†æ‰¾å‡ºç±»çš„ `+load` æ–¹æ³•ï¼Œåœ¨éå†æ‰¾å‡ºåˆ†ç±»çš„ `+load` æ–¹æ³•ï¼Œçˆ¶ç±»çš„ `+load` æ–¹æ³•å…ˆæ·»åŠ åˆ° `loadable_classes` æ•°ç»„ä¸­ï¼Œåœ¨æ·»åŠ ç±»çš„ `+load` æ–¹æ³•åˆ° `loadable_classes` æ•°ç»„ä¸­ã€‚åˆ†ç±»çš„ `+load`  æ–¹æ³•æ·»åŠ åˆ° `loadable_categories` æ•°ç»„ä¸­ã€‚
`call_load_methods` çš„æºç å¦‚ä¸‹ï¼š

```
void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    loadMethodLock.assertLocked();

    // Re-entrant calls do nothing; the outermost call will finish the job.
    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        // 1. Repeatedly call class +loads until there aren't any more
        while (loadable_classes_used > 0) {
            call_class_loads();
        }

        // 2. Call category +loads ONCE
        more_categories = call_category_loads();

        // 3. Run more +loads if there are classes OR more untried categories
    } while (loadable_classes_used > 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}
```

å…ˆè°ƒç”¨ `loadable_classes` æ•°ç»„ä¸­çš„ `+load` æ–¹æ³•åœ¨è°ƒç”¨ `loadable_categories` æ•°ç»„ä¸­çš„ `+load` æ–¹æ³•ã€‚
ä»ä¸Šé¢æºç ä¸­å¯ä»¥å‘ç°ï¼š

- çˆ¶ç±»çš„ `+load` æ–¹æ³•ä¸€å®šæ¯”å­ç±»çš„ `+load` æ–¹æ³•å…ˆè°ƒç”¨ã€‚
- ä¸»ç±»çš„ `+load` æ–¹æ³•ä¸€å®šæ¯”åˆ†ç±»çš„ `+load` æ–¹æ³•å…ˆè°ƒç”¨ã€‚

`map_images` ç®€åŒ–æºç å¦‚ä¸‹ï¼š

```
void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)
{
    ...
    // Fix up @selector references
    /// 1. æå–æ–¹æ³•ï¼Œå¹¶æ³¨å†Œåˆ°åä¸ºnamedSelectorsçš„å…¨å±€ map table ä¸­
    static size_t UnfixedSelectors;
    {
        mutex_locker_t lock(selLock);
        for (EACH_HEADER) {
            if (hi->hasPreoptimizedSelectors()) continue;
            bool isBundle = hi->isBundle();
            SEL *sels = _getObjc2SelectorRefs(hi, &count);
            UnfixedSelectors += count;
            for (i = 0; i < count; i++) {
                const char *name = sel_cname(sels[i]);
                SEL sel = sel_registerNameNoLock(name, isBundle);
                if (sels[i] != sel) {
                    sels[i] = sel;
                }
            }
        }
    }
    // Discover classes. Fix up unresolved future classes. Mark bundle classes.
    /// 2. å‘ç°ç±»ï¼Œä»é•œåƒæå–ç±»ä¿¡æ¯ï¼Œå¹¶å­˜åˆ°åä¸ºallocatedClassesçš„å…¨å±€ hash table ä¸­
    bool hasDyldRoots = dyld_shared_cache_some_image_overridden();

    for (EACH_HEADER) {
        if (! mustReadClasses(hi, hasDyldRoots)) {
            // Image is sufficiently optimized that we need not call readClass()
            continue;
        }

        classref_t const *classlist = _getObjc2ClassList(hi, &count);

        bool headerIsBundle = hi->isBundle();
        bool headerIsPreoptimized = hi->hasPreoptimizedClasses();

        for (i = 0; i < count; i++) {
            Class cls = (Class)classlist[i];
            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);

            if (newCls != cls  &&  newCls) {
                // Class was moved but not deleted. Currently this occurs 
                // only when the new class resolved a future class.
                // Non-lazily realize the class below.
                resolvedFutureClasses = (Class *)
                    realloc(resolvedFutureClasses, 
                            (resolvedFutureClassCount+1) * sizeof(Class));
                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;
            }
        }
    }

    ts.log("IMAGE TIMES: discover classes");

    // Fix up remapped classes
    /// 3. é‡æ–°è°ƒæ•´ç±»ä¹‹é—´çš„å¼•ç”¨
    if (!noClassesRemapped()) {
        for (EACH_HEADER) {
            Class *classrefs = _getObjc2ClassRefs(hi, &count);
            for (i = 0; i < count; i++) {
                remapClassRef(&classrefs[i]);
            }
            // fixme why doesn't test future1 catch the absence of this?
            classrefs = _getObjc2SuperRefs(hi, &count);
            for (i = 0; i < count; i++) {
                remapClassRef(&classrefs[i]);
            }
        }
    }

    ts.log("IMAGE TIMES: remap classes");

#if SUPPORT_FIXUP
    // Fix up old objc_msgSend_fixup call sites
    /// 4. æå–æ—§objc_msgSend_fixup
    for (EACH_HEADER) {
        ...
        for (i = 0; i < count; i++) {
            fixupMessageRef(refs+i);
        }
    }
#endif

    // Discover protocols. Fix up protocol refs.
    /// 5. æå– protocolsï¼Œå­˜å‚¨åˆ°å…¨å±€ map table
    for (EACH_HEADER) {
        extern objc_class OBJC_CLASS_$_Protocol;
        Class cls = (Class)&OBJC_CLASS_$_Protocol;
        ASSERT(cls);
        NXMapTable *protocol_map = protocols();
        bool isPreoptimized = hi->hasPreoptimizedProtocols();

        // Skip reading protocols if this is an image from the shared cache
        // and we support roots
        // Note, after launch we do need to walk the protocol as the protocol
        // in the shared cache is marked with isCanonical() and that may not
        // be true if some non-shared cache binary was chosen as the canonical
        // definition
        if (launchTime && isPreoptimized && cacheSupportsProtocolRoots) {
            if (PrintProtocols) {
                _objc_inform("PROTOCOLS: Skipping reading protocols in image: %s",
                             hi->fname());
            }
            continue;
        }

        bool isBundle = hi->isBundle();

        protocol_t * const *protolist = _getObjc2ProtocolList(hi, &count);
        for (i = 0; i < count; i++) {
            readProtocol(protolist[i], cls, protocol_map, 
                         isPreoptimized, isBundle);
        }
    }

    ts.log("IMAGE TIMES: discover protocols");

    // Fix up @protocol references
    ///6. å’Œç±»ä¸€æ ·ï¼Œprotocol ä¹Ÿæœ‰ç»§æ‰¿å…³ç³»ï¼Œæ­¤è¿‡ç¨‹ fixup å®ƒä»¬çš„ä¾èµ–å…³ç³»
    for (EACH_HEADER) {
        // At launch time, we know preoptimized image refs are pointing at the
        // shared cache definition of a protocol.  We can skip the check on
        // launch, but have to visit @protocol refs for shared cache images
        // loaded later.
        if (launchTime && cacheSupportsProtocolRoots && hi->isPreoptimized())
            continue;
        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &count);
        for (i = 0; i < count; i++) {
            remapProtocolRef(&protolist[i]);
        }
    }


    // Discover categories. Only do this after the initial category
    /// 7. æå– categoriesï¼Œå­˜å‚¨åˆ°å…¨å±€ map table
    if (didInitialAttachCategories) {
        for (EACH_HEADER) {
            load_categories_nolock(hi);
        }
    }

 
    // Category discovery MUST BE Late to avoid potential races
    // Realize non-lazy classes (for +load methods and static instances)
    /// 8. realize å«æœ‰+loadæ–¹æ³•æˆ–è€…é™æ€å®ä¾‹çš„ç±»
    for (EACH_HEADER) {
        classref_t const *classlist = 
            _getObjc2NonlazyClassList(hi, &count);
        for (i = 0; i < count; i++) {
            Class cls = remapClass(classlist[i]);
            if (!cls) continue;

            addClassTableEntry(cls);

            if (cls->isSwiftStable()) {
                if (cls->swiftMetadataInitializer()) {
                    _objc_fatal("Swift class %s with a metadata initializer "
                                "is not allowed to be non-lazy",
                                cls->nameForLogging());
                }
                // fixme also disallow relocatable classes
                // We can't disallow all Swift classes because of
                // classes like Swift.__EmptyArrayStorage
            }
            realizeClassWithoutSwift(cls, nil);
        }
    }

    ts.log("IMAGE TIMES: realize non-lazy classes");

    // Realize newly-resolved future classes, in case CF manipulates them
    /// 9.realize å«æœ‰RO_FUTUREæ ‡è¯†çš„ç±»ï¼Œè¿™äº›ç±»ä¸€èˆ¬æ˜¯ Core Foundation ä¸­çš„ç±»
    if (resolvedFutureClasses) {
        for (i = 0; i < resolvedFutureClassCount; i++) {
            Class cls = resolvedFutureClasses[i];
            if (cls->isSwiftStable()) {
                _objc_fatal("Swift class is not allowed to be future");
            }
            realizeClassWithoutSwift(cls, nil);
            cls->setInstancesRequireRawIsaRecursively(false/*inherited*/);
        }
        free(resolvedFutureClasses);
    }
    ...
}
```

- æå–æ–¹æ³•ï¼Œå¹¶æ³¨å†Œåˆ°åä¸º `namedSelectors` çš„å…¨å±€ `map table` ä¸­ã€‚
- å‘ç°ç±»ï¼Œä»é•œåƒæå–ç±»ä¿¡æ¯ï¼Œå¹¶å­˜åˆ°åä¸º `allocatedClasses` çš„å…¨å±€ `hash table` ä¸­ã€‚
- é‡æ–°è°ƒæ•´ç±»ä¹‹é—´çš„å¼•ç”¨ã€‚
- æå–æ—§ `objc_msgSend_fixup`ã€‚
- æå– `protocols`ï¼Œå­˜å‚¨åˆ°å…¨å±€ `map table`ã€‚
- å’Œç±»ä¸€æ ·ï¼Œ``protocol` ä¹Ÿæœ‰ç»§æ‰¿å…³ç³»ï¼Œæ­¤è¿‡ç¨‹é‡æ–°è°ƒæ•´å®ƒä»¬çš„ä¾èµ–å…³ç³»ã€‚
- æå– `categories`ï¼Œå­˜å‚¨åˆ°å…¨å±€ `map table`ã€‚
- `realize class` å«æœ‰ `+load` æ–¹æ³•æˆ–è€…é™æ€å®ä¾‹çš„ç±»ã€‚
- `realize class` å«æœ‰ `RO_FUTURE` æ ‡è¯†çš„ç±»ï¼Œè¿™äº›ç±»ä¸€èˆ¬æ˜¯ `Core Foundation` ä¸­çš„ç±»ã€‚

è¿™é‡Œä¸åšå…·ä½“åˆ†æï¼Œå…·ä½“åˆ†æçœ‹å‚è€ƒæ–‡ç« ã€‚

##### 3.12 æŸ¥æ‰¾ä¸»ç¨‹åºå¯æ‰§è¡Œæ–‡ä»¶çš„å…¥å£ç‚¹

é¦–å…ˆè°ƒç”¨ `getEntryFromLC_MAIN()` å‡½æ•°ï¼Œä» `Load Command` è¯»å– `LC_MAIN` å…¥å£ã€‚å¦‚æœæ²¡æœ‰ `LC_MAIN` å…¥å£ï¼Œå°±è°ƒç”¨ `getEntryFromLC_UNIXTHREAD()` å‡½æ•°ï¼Œä» `Load Command` è¯»å– `LC_UNIXTHREAD` å…¥å£ã€‚å› ä¸ºä¼šå°†è¿™ä¸ªå…¥å£ä½œä¸ºå‡½æ•°æŒ‡é’ˆè°ƒç”¨ï¼Œè¿™é‡Œè¦å¯¹å…¶è¿›è¡Œç­¾åã€‚ç„¶åè·³åˆ°`å…¥å£`å¤„æ‰§è¡Œï¼Œä¹‹åå°±è¿›å…¥äº† `main()` å‡½æ•°ã€‚
ä»¥ä¸‹æ˜¯ç®€åŒ–çš„æºç ï¼š

```
/// æŸ¥æ‰¾ä¸»ç¨‹åºå¯æ‰§è¡Œæ–‡ä»¶çš„å…¥å£ç‚¹
result = (uintptr_t)sMainExecutable->getEntryFromLC_MAIN();
if ( result != 0 ) {
}
else {
	result = (uintptr_t)sMainExecutable->getEntryFromLC_UNIXTHREAD();
	*startGlue = 0;
}
#if __has_feature(ptrauth_calls)
		/// startï¼ˆï¼‰å°†ç»“æœæŒ‡é’ˆä½œä¸ºå‡½æ•°æŒ‡é’ˆè°ƒç”¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¯¹å…¶è¿›è¡Œç­¾åã€‚
		result = (uintptr_t)__builtin_ptrauth_sign_unauthenticated((void*)result, 0, 0);
#endif

void* ImageLoaderMachO::getEntryFromLC_MAIN() const
{
	const uint32_t cmd_count = ((macho_header*)fMachOData)->ncmds;
	const struct load_command* const cmds = (struct load_command*)&fMachOData[sizeof(macho_header)];
	const struct load_command* cmd = cmds;
	for (uint32_t i = 0; i < cmd_count; ++i) {
		if ( cmd->cmd == LC_MAIN ) {
			entry_point_command* mainCmd = (entry_point_command*)cmd;
			void* entry = (void*)(mainCmd->entryoff + (char*)fMachOData);
			// <rdar://problem/8543820&9228031> verify entry point is in image
			if ( this->containsAddress(entry) )
				return entry;
			else
				throw "LC_MAIN entryoff is out of range";
		}
		cmd = (const struct load_command*)(((char*)cmd)+cmd->cmdsize);
	}
	return NULL;
}

void* ImageLoaderMachO::getEntryFromLC_UNIXTHREAD() const
{
	const uint32_t cmd_count = ((macho_header*)fMachOData)->ncmds;
	const struct load_command* const cmds = (struct load_command*)&fMachOData[sizeof(macho_header)];
	const struct load_command* cmd = cmds;
	for (uint32_t i = 0; i < cmd_count; ++i) {
		if ( cmd->cmd == LC_UNIXTHREAD ) {
	#elif __arm64__ && !__arm64e__
			// temp support until <rdar://39514191> is fixed
			const uint64_t* regs64 = (uint64_t*)(((char*)cmd) + 16);
			void* entry = (void*)(regs64[32] + fSlide); // arm_thread_state64_t.__pc
			// <rdar://problem/8543820&9228031> verify entry point is in image
			if ( this->containsAddress(entry) )
				return entry;
	#endif
		}
		cmd = (const struct load_command*)(((char*)cmd)+cmd->cmdsize);
	}
	throw "no valid entry point";
}
```

#### 4. æ€»ç»“

![image-20200618164515116](http://blog.objccf.com/blog/2020-06-18-084515.png)

### 0x07 æœ€åçš„æœ€å

å¦‚æœ‰é”™è¯¯ï¼Œè¯·è”ç³»ä¿®æ­£ã€‚è°¢è°¢

### 0x033 å‚è€ƒ

- [dyldå¯åŠ¨æµç¨‹](https://leylfl.github.io/2018/05/28/dyldå¯åŠ¨æµç¨‹/)

- [Mach-O/loader](https://opensource.apple.com/source/cctools/cctools-795/include/Mach-O/loader.h)

- [æ·±å…¥è§£æMac OS X & iOS æ“ä½œç³»ç»Ÿ](https://book.douban.com/subject/25870206/)

- [iOSåº”ç”¨é€†å‘ä¸å®‰å…¨](https://book.douban.com/subject/30239776/)

- [dyld-733.8](https://opensource.apple.com/source/dyld/dyld-733.8/)

- [xnu-6153.81.5](https://opensource.apple.com/source/xnu/xnu-6153.81.5/)

- [æ–‡ç« å¤§ä½“ç›®å½•å‚è€ƒ-æœæš®-dyldå¯åŠ¨æµç¨‹](https://leylfl.github.io/2018/05/28/dyldå¯åŠ¨æµç¨‹/)

- [libsystem-159](https://opensource.apple.com/source/Libsystem/Libsystem-159/init.c)

- [libdispatch-1173.40.5](https://opensource.apple.com/source/libdispatch/libdispatch-1173.40.5/src/queue.c.auto.html)

- [objc4-781](https://opensource.apple.com/source/objc4/objc4-781/runtime/objc-os.mm.auto.html)

- [ä½ çœŸçš„äº†è§£ load æ–¹æ³•ä¹ˆï¼Ÿ](https://draveness.me/load/)

- [Objective-C Runtime åˆ†æ](https://zhangbuhuai.com/post/runtime.html)







